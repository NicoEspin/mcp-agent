<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Session Dashboard</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .controls {
            padding: 20px;
            background: white;
            margin: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .controls h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 400;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group label {
            font-weight: 500;
            min-width: 120px;
        }

        input,
        select,
        textarea {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s ease;
            flex: 1;
            max-width: 300px;
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
        }

        .btn-danger:hover {
            background: #c53030;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #38a169;
            color: white;
        }

        .btn-success:hover {
            background: #2f855a;
            transform: translateY(-1px);
        }

        .sessions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            padding: 0 20px 20px;
        }

        .session-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .session-card:hover {
            transform: translateY(-2px);
        }

        .session-header {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-id {
            font-weight: 500;
            font-size: 16px;
        }

        .session-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-active {
            background: #48bb78;
            color: white;
        }

        .status-inactive {
            background: #e53e3e;
            color: white;
        }

        .status-unknown {
            background: #ed8936;
            color: white;
        }

        .session-controls {
            padding: 15px 20px;
            background: #f8f9fa;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .session-controls button {
            flex: 1;
            min-width: 80px;
            font-size: 12px;
            padding: 8px 12px;
        }

        .screen-container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .screen-viewer {
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            overflow: hidden;
            max-width: 100%;
            background: #f7fafc;
            position: relative;
        }

        .screen-viewer img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .screen-placeholder {
            width: 400px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #a0aec0;
            font-size: 16px;
            background: #f7fafc;
        }

        .linkedin-tasks {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
        }

        .linkedin-tasks h3 {
            color: #4a5568;
            margin-bottom: 15px;
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .task-form {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .task-form input,
        .task-form textarea {
            width: 100%;
            margin-bottom: 10px;
        }

        .task-form textarea {
            resize: vertical;
            min-height: 80px;
        }

        .logs {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
            max-height: 200px;
            overflow-y: auto;
        }

        .logs h3 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 500;
        }

        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }

        .log-info {
            background: #e6fffa;
            color: #38a169;
        }

        .log-error {
            background: #fed7d7;
            color: #e53e3e;
        }

        .log-warning {
            background: #fefcbf;
            color: #d69e2e;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-header h3 {
            color: #4a5568;
            margin: 0;
        }

        .connection-indicator {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .connected {
            background: #c6f6d5;
            color: #2f855a;
        }

        .disconnected {
            background: #fed7d7;
            color: #c53030;
        }

        .fps-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .sessions-grid {
                grid-template-columns: 1fr;
                padding: 0 10px 20px;
            }

            .controls {
                margin: 10px;
            }

            .control-group {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group label {
                min-width: auto;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üöÄ Browser Session Dashboard</h1>
        <div class="connection-indicator disconnected" id="connectionStatus">Disconnected</div>
    </div>

    <div class="controls">
        <h2>üéõÔ∏è Global Controls</h2>
        <div class="control-group">
            <label>Base URL:</label>
            <input type="text" id="baseUrl" value="http://localhost:3001" placeholder="http://localhost:3001">
            <button class="btn-primary" onclick="updateConnection()">Connect</button>
        </div>

        <div class="control-group">
            <label>New Session ID:</label>
            <input type="text" id="newSessionId" placeholder="session-name" maxlength="50">
            <button class="btn-success" onclick="createSession()">Create Session</button>
            <button class="btn-primary" onclick="refreshSessions()">Refresh All</button>
        </div>
    </div>

    <div class="sessions-grid" id="sessionsGrid">
        <!-- Sessions will be dynamically added here -->
    </div>

    <!-- Modal for editing tasks -->
    <div class="modal" id="taskModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">LinkedIn Task</h3>
            </div>
            <div id="modalBody">
                <!-- Modal content will be dynamically added -->
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="executeTask()">Execute</button>
                <button class="btn-danger" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Auto-detect base URL from current origin
        function detectBaseUrl() {
            const currentOrigin = window.location.origin;

            // If running from file:// protocol, default to localhost
            if (currentOrigin === 'null' || currentOrigin.startsWith('file://')) {
                return 'http://localhost:3001';
            }

            // If running from a web server, detect the API port
            // Try common development ports or use same origin
            const commonPorts = ['3001', '3000', '8080', '4000'];
            const currentPort = window.location.port;

            // If we're on a known dev port, try the API port
            if (currentPort && commonPorts.includes(currentPort)) {
                // If on 3000, try 3001; if on other ports, try 3001 first
                const apiPort = currentPort === '3000' ? '3001' : '3001';
                return `${window.location.protocol}//${window.location.hostname}:${apiPort}`;
            }

            // Otherwise use current origin (same server)
            return currentOrigin;
        }

        let baseUrl = detectBaseUrl();
        let sessions = new Map(); // sessionId -> { socket, status, lastFrame, logs }
        let currentModalTask = null;
        let currentModalSession = null;

        // Initialize
        document.getElementById('baseUrl').value = baseUrl;
        updateConnection();

        function updateConnection() {
            baseUrl = document.getElementById('baseUrl').value.trim().replace(/\/$/, '');
            document.getElementById('connectionStatus').textContent = 'Connecting...';
            document.getElementById('connectionStatus').className = 'connection-indicator disconnected';

            // Test connection
            fetch(`${baseUrl}/api/zion/linkedin/session-state`)
                .then(res => res.ok ? 'connected' : 'error')
                .catch(() => 'error')
                .then(status => {
                    const indicator = document.getElementById('connectionStatus');
                    if (status === 'connected') {
                        indicator.textContent = 'Connected';
                        indicator.className = 'connection-indicator connected';
                        refreshSessions();
                    } else {
                        indicator.textContent = 'Connection Failed';
                        indicator.className = 'connection-indicator disconnected';
                    }
                });
        }

        function createSession() {
            const sessionId = document.getElementById('newSessionId').value.trim();
            if (!sessionId) {
                alert('Please enter a session ID');
                return;
            }

            if (sessions.has(sessionId)) {
                alert('Session already exists');
                return;
            }

            // Create session entry
            sessions.set(sessionId, {
                socket: null,
                status: 'unknown',
                lastFrame: null,
                logs: []
            });

            renderSessions();
            document.getElementById('newSessionId').value = '';

            // Start the session by opening LinkedIn
            startSession(sessionId);
        }

        function refreshSessions() {
            // Fetch session list from server
            fetch(`${baseUrl}/api/zion/linkedin/sessions`)
                .then(res => res.json())
                .then(sessionList => {
                    // Update local sessions map with server data
                    sessions.clear();
                    sessionList.forEach(sessionInfo => {
                        if (!sessions.has(sessionInfo.sessionId)) {
                            sessions.set(sessionInfo.sessionId, {
                                socket: null,
                                status: 'active',
                                lastFrame: null,
                                logs: [],
                                url: sessionInfo.url,
                                lastUsedAt: sessionInfo.lastUsedAt
                            });
                        }
                    });
                    renderSessions();
                })
                .catch(err => {
                    console.error('Failed to fetch sessions:', err);
                    // Fallback to local sessions
                    renderSessions();
                });
        }

        function renderSessions() {
            const grid = document.getElementById('sessionsGrid');
            grid.innerHTML = '';

            if (sessions.size === 0) {
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #a0aec0; font-size: 18px;">No active sessions. Create a session to get started.</div>';
                return;
            }

            sessions.forEach((sessionData, sessionId) => {
                const sessionCard = createSessionCard(sessionId, sessionData);
                grid.appendChild(sessionCard);
            });
        }

        function createSessionCard(sessionId, sessionData) {
            const card = document.createElement('div');
            card.className = 'session-card';
            card.id = `session-${sessionId}`;

            const statusClass = sessionData.status === 'active' ? 'status-active' :
                sessionData.status === 'inactive' ? 'status-inactive' : 'status-unknown';

            card.innerHTML = `
                <div class="session-header">
                    <div class="session-id">üì± ${sessionId}</div>
                    <div class="session-status ${statusClass}">${sessionData.status.toUpperCase()}</div>
                </div>
                
                <div class="session-controls">
                    <button class="btn-success" onclick="startSession('${sessionId}')">Start</button>
                    <button class="btn-primary" onclick="checkSessionState('${sessionId}')">Check State</button>
                    <button class="btn-danger" onclick="stopSession('${sessionId}')">Stop</button>
                    <button class="btn-danger" onclick="deleteSession('${sessionId}')">Delete</button>
                </div>

                <div style="padding: 10px 20px; background: #f8f9fa; border-top: 1px solid #e2e8f0;">
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <label style="font-size: 12px; font-weight: 500;">FPS:</label>
                        <select id="fps-${sessionId}" style="padding: 4px 8px; font-size: 12px; border: 1px solid #e1e5e9; border-radius: 4px;">
                            <option value="1">1 FPS</option>
                            <option value="2" selected>2 FPS</option>
                            <option value="3">3 FPS</option>
                            <option value="5">5 FPS</option>
                            <option value="10">10 FPS</option>
                        </select>
                        <button class="btn-primary" onclick="updateStreamFPS('${sessionId}')" style="padding: 4px 12px; font-size: 12px;">Update FPS</button>
                        <div style="flex: 1;"></div>
                        <label style="font-size: 12px; font-weight: 500;">Mode:</label>
                        <button id="mode-${sessionId}" class="btn-primary" onclick="toggleInteractionMode('${sessionId}')" style="padding: 4px 12px; font-size: 12px;">Click Mode</button>
                    </div>
                </div>

                <div class="screen-container">
                    <div class="screen-viewer" id="screen-${sessionId}">
                        <div class="screen-placeholder">Click "Start" to initialize session</div>
                        <div class="fps-indicator" id="fps-${sessionId}" style="display: none;">0 FPS</div>
                    </div>
                </div>

                <div class="linkedin-tasks">
                    <h3>üîó LinkedIn Actions</h3>
                    
                    <div class="task-form">
                        <input type="text" placeholder="Profile URL" id="profileUrl-${sessionId}">
                        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                            <button class="btn-primary" onclick="openTaskModal('${sessionId}', 'send-message')">Send Message</button>
                            <button class="btn-primary" onclick="openTaskModal('${sessionId}', 'send-connection')">Send Connection</button>
                            <button class="btn-success" onclick="checkConnection('${sessionId}')">Check Connection</button>
                            <button class="btn-success" onclick="openTaskModal('${sessionId}', 'read-chat')">Read Chat</button>
                        </div>
                    </div>
                </div>

                <div class="logs">
                    <h3>üìã Logs</h3>
                    <div id="logs-${sessionId}">
                        <div class="log-entry log-info">Session created</div>
                    </div>
                </div>
            `;

            return card;
        }

        function addLog(sessionId, message, type = 'info') {
            const sessionData = sessions.get(sessionId);
            if (!sessionData) return;

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, message, type };
            sessionData.logs.push(logEntry);

            // Keep only last 50 logs
            if (sessionData.logs.length > 50) {
                sessionData.logs = sessionData.logs.slice(-50);
            }

            // Update UI
            const logsContainer = document.getElementById(`logs-${sessionId}`);
            if (logsContainer) {
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry log-${type}`;
                logDiv.textContent = `[${timestamp}] ${message}`;
                logsContainer.appendChild(logDiv);
                logsContainer.scrollTop = logsContainer.scrollHeight;

                // Keep only last 50 in DOM too
                while (logsContainer.children.length > 50) {
                    logsContainer.removeChild(logsContainer.firstChild);
                }
            }
        }

        function startSession(sessionId) {
            addLog(sessionId, 'Starting session...', 'info');

            // Update placeholder to show we're starting
            const screenContainer = document.getElementById(`screen-${sessionId}`);
            if (screenContainer) {
                screenContainer.innerHTML = `
                    <div class="screen-placeholder">Initializing browser session...</div>
                    <div class="fps-indicator" id="fps-${sessionId}" style="display: none;">0 FPS</div>
                `;
            }

            // Check if session exists on server, if yes use launch-session, otherwise use open
            const sessionData = sessions.get(sessionId);
            const isExistingSession = sessionData && sessionData.url && sessionData.url !== 'unknown';
            
            const endpoint = isExistingSession ? 'launch-session' : 'open';
            const payload = isExistingSession ? { sessionId } : { sessionId };

            fetch(`${baseUrl}/api/zion/linkedin/${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(res => res.json())
                .then(data => {
                    addLog(sessionId, 'Browser opened successfully', 'info');
                    updateSessionStatus(sessionId, 'active');

                    // Update placeholder to show we're connecting to stream
                    if (screenContainer) {
                        screenContainer.innerHTML = `
                            <div class="screen-placeholder">Connecting to screenshot stream...</div>
                            <div class="fps-indicator" id="fps-${sessionId}" style="display: none;">0 FPS</div>
                        `;
                    }

                    // Start streaming
                    startStreaming(sessionId);
                })
                .catch(err => {
                    addLog(sessionId, `Failed to start browser: ${err.message}`, 'error');
                    updateSessionStatus(sessionId, 'inactive');
                    
                    // Reset placeholder on error
                    if (screenContainer) {
                        screenContainer.innerHTML = `
                            <div class="screen-placeholder">Failed to start session. Click "Start" to retry.</div>
                            <div class="fps-indicator" id="fps-${sessionId}" style="display: none;">0 FPS</div>
                        `;
                    }
                });
        }

        function startStreaming(sessionId) {
            const sessionData = sessions.get(sessionId);
            if (!sessionData) return;

            // Disconnect existing socket
            if (sessionData.socket) {
                sessionData.socket.disconnect();
            }

            // Get current FPS setting or default to 2
            const fpsSelect = document.getElementById(`fps-${sessionId}`);
            const fps = fpsSelect ? parseInt(fpsSelect.value) : 2;

            // Create new socket connection for this session
            const socket = io(`${baseUrl}/api/zion/stream`, {
                path: "/api/zion/socket.io",
                query: { sessionId, fps: fps },
                transports: ["websocket", "polling"],
            });

            sessionData.socket = socket;
            setupSocketEvents(socket, sessionId);
        }

        function stopSession(sessionId) {
            addLog(sessionId, 'Stopping session...', 'info');

            fetch(`${baseUrl}/api/zion/linkedin/stop-session`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        addLog(sessionId, 'Session stopped successfully', 'info');
                        updateSessionStatus(sessionId, 'inactive');

                        // Disconnect streaming
                        const sessionData = sessions.get(sessionId);
                        if (sessionData && sessionData.socket) {
                            sessionData.socket.disconnect();
                            sessionData.socket = null;
                        }

                        // Clear screen
                        const screenContainer = document.getElementById(`screen-${sessionId}`);
                        if (screenContainer) {
                            screenContainer.innerHTML = '<div class="screen-placeholder">Session stopped</div>';
                        }
                    } else {
                        addLog(sessionId, `Failed to stop session: ${data.message}`, 'error');
                    }
                })
                .catch(err => {
                    addLog(sessionId, `Failed to stop session: ${err.message}`, 'error');
                });
        }

        function deleteSession(sessionId) {
            if (!confirm(`Delete session "${sessionId}"? This action cannot be undone.`)) {
                return;
            }

            // First stop the session
            stopSession(sessionId);

            // Remove from our local state
            sessions.delete(sessionId);

            // Remove from UI
            const sessionCard = document.getElementById(`session-${sessionId}`);
            if (sessionCard) {
                sessionCard.remove();
            }

            addLog(sessionId, 'Session deleted', 'warning');
        }

        function checkSessionState(sessionId) {
            addLog(sessionId, 'Checking session state...', 'info');

            fetch(`${baseUrl}/api/zion/linkedin/session-state?sessionId=${sessionId}`)
                .then(res => res.json())
                .then(data => {
                    const status = data.isLoggedIn ? 'logged in' : 'not logged in';
                    const confidence = data.confidence ? ` (${Math.round(data.confidence * 100)}% confident)` : '';
                    addLog(sessionId, `Session state: ${status}${confidence}`, 'info');

                    if (data.reason) {
                        addLog(sessionId, `Reason: ${data.reason}`, 'info');
                    }

                    updateSessionStatus(sessionId, data.isLoggedIn ? 'active' : 'inactive');
                })
                .catch(err => {
                    addLog(sessionId, `Failed to check session state: ${err.message}`, 'error');
                });
        }

        function updateSessionStatus(sessionId, status) {
            const sessionData = sessions.get(sessionId);
            if (sessionData) {
                sessionData.status = status;

                // Update UI
                const statusElement = document.querySelector(`#session-${sessionId} .session-status`);
                if (statusElement) {
                    statusElement.textContent = status.toUpperCase();
                    statusElement.className = `session-status ${status === 'active' ? 'status-active' :
                            status === 'inactive' ? 'status-inactive' : 'status-unknown'
                        }`;
                }
            }
        }

        function checkConnection(sessionId) {
            const profileUrl = document.getElementById(`profileUrl-${sessionId}`).value.trim();
            if (!profileUrl) {
                alert('Please enter a profile URL');
                return;
            }

            addLog(sessionId, 'Checking connection status...', 'info');

            fetch(`${baseUrl}/api/zion/linkedin/check-connection`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId, profileUrl })
            })
                .then(res => res.json())
                .then(connected => {
                    const status = connected ? 'Connected' : 'Not connected';
                    addLog(sessionId, `Connection status: ${status}`, connected ? 'info' : 'warning');
                })
                .catch(err => {
                    addLog(sessionId, `Failed to check connection: ${err.message}`, 'error');
                });
        }

        function openTaskModal(sessionId, taskType) {
            currentModalSession = sessionId;
            currentModalTask = taskType;

            const modal = document.getElementById('taskModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');

            const profileUrl = document.getElementById(`profileUrl-${sessionId}`).value;

            title.textContent = `${taskType.replace('-', ' ').toUpperCase()} - ${sessionId}`;

            let bodyContent = `<input type="text" id="modalProfileUrl" placeholder="Profile URL" value="${profileUrl}" style="width: 100%; margin-bottom: 10px;">`;

            switch (taskType) {
                case 'send-message':
                    bodyContent += `<textarea id="modalMessage" placeholder="Message content..." style="width: 100%; height: 120px;"></textarea>`;
                    break;
                case 'send-connection':
                    bodyContent += `<textarea id="modalNote" placeholder="Connection note (optional)..." style="width: 100%; height: 80px;"></textarea>`;
                    break;
                case 'read-chat':
                    bodyContent += `
                        <input type="number" id="modalLimit" placeholder="Message limit (default: 30)" value="30" style="width: 100%; margin-bottom: 10px;">
                        <input type="text" id="modalThreadHint" placeholder="Thread hint (optional)" style="width: 100%;">
                    `;
                    break;
            }

            body.innerHTML = bodyContent;
            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('taskModal').classList.remove('active');
            currentModalTask = null;
            currentModalSession = null;
        }

        function executeTask() {
            if (!currentModalTask || !currentModalSession) return;

            const profileUrl = document.getElementById('modalProfileUrl').value.trim();
            if (!profileUrl) {
                alert('Please enter a profile URL');
                return;
            }

            let payload = { sessionId: currentModalSession, profileUrl };
            let endpoint = '';

            switch (currentModalTask) {
                case 'send-message':
                    const message = document.getElementById('modalMessage').value.trim();
                    if (!message) {
                        alert('Please enter a message');
                        return;
                    }
                    payload.message = message;
                    endpoint = 'send-message';
                    break;
                case 'send-connection':
                    const note = document.getElementById('modalNote').value.trim();
                    if (note) payload.note = note;
                    endpoint = 'send-connection';
                    break;
                case 'read-chat':
                    const limit = parseInt(document.getElementById('modalLimit').value) || 30;
                    const threadHint = document.getElementById('modalThreadHint').value.trim();
                    payload.limit = limit;
                    if (threadHint) payload.threadHint = threadHint;
                    endpoint = 'read-chat';
                    break;
                default:
                    alert('Unknown task type');
                    return;
            }

            addLog(currentModalSession, `Executing ${currentModalTask}...`, 'info');

            fetch(`${baseUrl}/api/zion/linkedin/${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(res => res.json())
                .then(data => {
                    addLog(currentModalSession, `${currentModalTask} completed successfully`, 'info');
                    if (data.result) {
                        addLog(currentModalSession, `Result: ${JSON.stringify(data.result).substring(0, 100)}...`, 'info');
                    }
                    closeModal();
                })
                .catch(err => {
                    addLog(currentModalSession, `${currentModalTask} failed: ${err.message}`, 'error');
                    closeModal();
                });
        }

        // Global state for interaction modes
        const interactionModes = new Map(); // sessionId -> 'click' | 'type'

        function handleScreenClick(event, sessionId) {
            event.preventDefault();
            
            const img = event.target;
            const rect = img.getBoundingClientRect();
            
            // Calculate click coordinates relative to the image
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Scale coordinates to match browser viewport if image is scaled
            const scaleX = img.naturalWidth / img.width;
            const scaleY = img.naturalHeight / img.height;
            
            const actualX = Math.round(x * scaleX);
            const actualY = Math.round(y * scaleY);

            const mode = interactionModes.get(sessionId) || 'click';

            if (mode === 'click') {
                handleClick(sessionId, actualX, actualY);
            } else if (mode === 'type') {
                handleType(sessionId, actualX, actualY);
            }
        }

        function handleClick(sessionId, x, y) {
            addLog(sessionId, `Click at (${x}, ${y})`, 'info');
            
            // Send click to server
            fetch(`${baseUrl}/api/zion/linkedin/click`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sessionId: sessionId,
                    x: x,
                    y: y
                })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        addLog(sessionId, `Click successful on ${data.element}`, 'info');
                    } else {
                        addLog(sessionId, `Click failed: ${data.message}`, 'warning');
                    }
                })
                .catch(err => {
                    addLog(sessionId, `Click failed: ${err.message}`, 'error');
                });
        }

        function handleType(sessionId, x, y) {
            const text = prompt('Enter text to type:');
            if (text === null || text === '') {
                return; // User cancelled or entered empty text
            }

            addLog(sessionId, `Type "${text}" at (${x}, ${y})`, 'info');
            
            // Send type to server
            fetch(`${baseUrl}/api/zion/linkedin/type`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sessionId: sessionId,
                    x: x,
                    y: y,
                    text: text
                })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        addLog(sessionId, `Type successful on ${data.element} (${data.elementType})`, 'info');
                    } else {
                        addLog(sessionId, `Type failed: ${data.message}`, 'warning');
                    }
                })
                .catch(err => {
                    addLog(sessionId, `Type failed: ${err.message}`, 'error');
                });
        }

        function toggleInteractionMode(sessionId) {
            const currentMode = interactionModes.get(sessionId) || 'click';
            const newMode = currentMode === 'click' ? 'type' : 'click';
            interactionModes.set(sessionId, newMode);
            
            const button = document.getElementById(`mode-${sessionId}`);
            button.textContent = newMode === 'click' ? 'Click Mode' : 'Type Mode';
            button.className = newMode === 'click' ? 'btn-primary' : 'btn-success';
            
            addLog(sessionId, `Switched to ${newMode} mode`, 'info');
        }

        function updateStreamFPS(sessionId) {
            const fpsSelect = document.getElementById(`fps-${sessionId}`);
            const newFps = parseInt(fpsSelect.value);
            
            addLog(sessionId, `Updating FPS to ${newFps}...`, 'info');
            
            // Restart streaming with new FPS
            const sessionData = sessions.get(sessionId);
            if (sessionData && sessionData.socket) {
                sessionData.socket.disconnect();
                
                // Wait a bit then reconnect with new FPS
                setTimeout(() => {
                    const socket = io(`${baseUrl}/api/zion/stream`, {
                        path: "/api/zion/socket.io",
                        query: { sessionId, fps: newFps },
                        transports: ["websocket", "polling"],
                    });
                    
                    sessionData.socket = socket;
                    setupSocketEvents(socket, sessionId);
                    addLog(sessionId, `FPS updated to ${newFps}`, 'info');
                }, 500);
            }
        }

        function setupSocketEvents(socket, sessionId) {
            let frameCount = 0;
            let lastFpsUpdate = Date.now();

            socket.on('connect', () => {
                addLog(sessionId, 'Stream connected', 'info');
                document.getElementById(`fps-${sessionId}`).style.display = 'block';
                
                // Update placeholder to indicate we're waiting for first frame
                const screenContainer = document.getElementById(`screen-${sessionId}`);
                if (screenContainer && !screenContainer.querySelector('img')) {
                    screenContainer.innerHTML = `
                        <div class="screen-placeholder">Stream connected, waiting for first screenshot...</div>
                        <div class="fps-indicator" id="fps-${sessionId}">0 FPS</div>
                    `;
                }
                
                // Set a timeout to show error if no frames received after 10 seconds
                setTimeout(() => {
                    if (screenContainer && screenContainer.querySelector('.screen-placeholder')) {
                        const placeholder = screenContainer.querySelector('.screen-placeholder');
                        if (placeholder && placeholder.textContent.includes('waiting for first screenshot')) {
                            placeholder.textContent = 'No screenshots received. Browser session may not be active or accessible.';
                            addLog(sessionId, 'No screenshots received after 10 seconds. Check if browser session is properly initialized.', 'warning');
                        }
                    }
                }, 10000);
            });

            socket.on('frame', (data) => {
                frameCount++;
                const now = Date.now();

                // Update FPS every second
                if (now - lastFpsUpdate >= 1000) {
                    const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                    document.getElementById(`fps-${sessionId}`).textContent = `${fps} FPS`;
                    frameCount = 0;
                    lastFpsUpdate = now;
                }

                // Update screen
                const screenContainer = document.getElementById(`screen-${sessionId}`);
                if (screenContainer) {
                    screenContainer.innerHTML = `
                        <img src="data:${data.mimeType};base64,${data.data}" alt="Browser Screen" style="cursor: pointer;" onclick="handleScreenClick(event, '${sessionId}')">
                        <div class="fps-indicator" id="fps-${sessionId}">${document.getElementById(`fps-${sessionId}`) ? document.getElementById(`fps-${sessionId}`).textContent : '0 FPS'}</div>
                    `;
                }

                sessionData.lastFrame = data;
            });

            socket.on('frame_error', (error) => {
                const errorMsg = error.message || 'Unknown stream error';
                addLog(sessionId, `Stream error: ${errorMsg}`, 'error');
                const screenContainer = document.getElementById(`screen-${sessionId}`);
                if (screenContainer) {
                    screenContainer.innerHTML = `
                        <div class="screen-placeholder">Stream Error: ${errorMsg}<br><small>Try restarting the session or check browser logs</small></div>
                        <div class="fps-indicator" id="fps-${sessionId}" style="display: none;">0 FPS</div>
                    `;
                }
            });

            socket.on('disconnect', () => {
                addLog(sessionId, 'Stream disconnected', 'warning');
                document.getElementById(`fps-${sessionId}`).style.display = 'none';
            });
        }

        // Initialize by loading existing sessions
        window.addEventListener('load', () => {
            // Load existing sessions from server
            setTimeout(() => {
                refreshSessions();
            }, 1000);
        });
    </script>
</body>

</html>