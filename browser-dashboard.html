<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Read Chat Debug (No Storage)</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        :root {
            --bg: #0b1020;
            --panel: rgba(255, 255, 255, 0.06);
            --panel2: rgba(255, 255, 255, 0.08);
            --border: rgba(255, 255, 255, 0.12);
            --text: rgba(255, 255, 255, 0.92);
            --muted: rgba(255, 255, 255, 0.65);
            --good: #40c463;
            --bad: #ff5c5c;
            --warn: #f7b955;
            --accent: #8b5cf6;
        }

        * {
            box-sizing: border-box;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 600px at 20% 10%, rgba(139, 92, 246, 0.25), transparent 60%),
                radial-gradient(900px 500px at 80% 20%, rgba(59, 130, 246, 0.18), transparent 55%),
                var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        .wrap {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 16px;
            padding: 16px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
        }

        .title {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.2px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 0 0 10px 0;
        }

        .subtle {
            color: var(--muted);
            font-size: 12px;
            line-height: 1.4;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        label {
            font-size: 12px;
            color: var(--muted);
            display: block;
            margin-bottom: 6px;
        }

        input,
        select,
        textarea {
            width: 100%;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 10px;
            outline: none;
        }

        textarea {
            min-height: 78px;
            resize: vertical;
        }

        input:focus,
        textarea:focus,
        select:focus {
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.15);
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            appearance: none;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            padding: 9px 11px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 650;
            font-size: 12px;
            transition: transform 0.05s ease, background 0.15s ease, border-color 0.15s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(139, 92, 246, 0.5);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.primary {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.55);
        }

        .btn.danger {
            background: rgba(255, 92, 92, 0.15);
            border-color: rgba(255, 92, 92, 0.45);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.18);
            font-size: 12px;
            color: var(--muted);
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: var(--warn);
            box-shadow: 0 0 0 4px rgba(247, 185, 85, 0.15);
        }

        .dot.good {
            background: var(--good);
            box-shadow: 0 0 0 4px rgba(64, 196, 99, 0.15);
        }

        .dot.bad {
            background: var(--bad);
            box-shadow: 0 0 0 4px rgba(255, 92, 92, 0.15);
        }

        .viewer {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.35);
            aspect-ratio: 16 / 9;
            max-height: 78vh;
        }

        /* FIX: estado de focus del stream (visual + bloquea scroll del body mientras está enfocado) */
        .viewer.focused {
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.15);
        }

        .viewer img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        .overlay {
            position: absolute;
            inset: 0;
            outline: none;
            cursor: crosshair;
            touch-action: none;
        }

        .hint {
            position: absolute;
            left: 12px;
            bottom: 12px;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 8px 10px;
            border-radius: 12px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.85);
        }

        pre {
            margin: 0;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 10px;
            overflow: auto;
            max-height: 310px;
            font-size: 12px;
            line-height: 1.35;
        }

        .log {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.78);
            white-space: pre-wrap;
        }

        .mutedline {
            height: 1px;
            background: rgba(255, 255, 255, 0.08);
            margin: 12px 0;
        }

        @media (max-width: 980px) {
            .wrap {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <!-- LEFT -->
        <div class="card">
            <div class="title">
                <span>Config (sin storage)</span>
                <span class="pill"><span id="wsDot" class="dot"></span><span id="wsStatus">WS:
                        desconectado</span></span>
            </div>

            <div class="grid">
                <div>
                    <label>Backend Base URL</label>
                    <input id="baseUrl" placeholder="http://localhost:3001" />
                    <div class="subtle" style="margin-top: 6px">
                        Si abrís este HTML con Live Server (5500), poné acá tu backend (ej: http://localhost:3000).
                    </div>
                </div>
                <div>
                    <label>API Prefix</label>
                    <input id="apiPrefix" placeholder="/api/zion" />
                    <div class="subtle" style="margin-top: 6px">
                        Tu Socket Gateway usa <code>/api/zion</code>. Si no tenés prefijo global, dejalo vacío.
                    </div>
                </div>

                <div>
                    <label>Session ID (no persistido)</label>
                    <input id="sessionId" value="default" />
                </div>

                <div>
                    <label>FPS (1-10)</label>
                    <input id="fps" type="number" min="1" max="10" value="2" />
                </div>

                <div>
                    <label>Viewport remoto (para mapear clicks)</label>
                    <div class="row">
                        <input id="vpW" type="number" value="1280" style="width: 48%" />
                        <input id="vpH" type="number" value="720" style="width: 48%" />
                    </div>
                </div>

                <div>
                    <label>Acciones</label>
                    <div class="row">
                        <button class="btn primary" id="btnConnect">Conectar stream</button>
                        <button class="btn" id="btnDisconnect">Desconectar</button>
                    </div>
                </div>
            </div>

            <div class="mutedline"></div>

            <div class="title" style="margin-top: 0">
                <span>LinkedIn</span>
                <span class="pill"><span class="dot good" style="opacity: 0.85"></span><span id="lastFrame">Frame:
                        -</span></span>
            </div>

            <div class="row">
                <button class="btn primary" id="btnOpen">POST /linkedin/open</button>
                <button class="btn" id="btnReload">CMD reload</button>
                <button class="btn" id="btnListTabs">CMD listTabs</button>
            </div>

            <div class="subtle" style="margin-top: 10px">
                No hay polling de session-state, ni storage. Todo es manual para evitar bucles.
            </div>

            <div class="mutedline"></div>

            <div class="title" style="margin-top: 0">
                <span>Read Chat</span>
                <span class="pill"><span class="dot" id="httpDot"></span><span id="httpStatus">HTTP: idle</span></span>
            </div>

            <div>
                <label>profileUrl</label>
                <input id="profileUrl" placeholder="https://www.linkedin.com/in/..." />
            </div>

            <div style="margin-top: 10px">
                <label>note (opcional)</label>
                <textarea id="connNote" placeholder="Dejá vacío para enviar SIN nota"></textarea>
            </div>

            <div class="grid" style="margin-top: 10px">
                <div>
                    <label>limit</label>
                    <input id="limit" type="number" value="30" min="1" max="200" />
                </div>
                <div>
                    <label>threadHint (opcional)</label>
                    <input id="threadHint" placeholder="ej: last / recent / name..." />
                </div>
            </div>

            <div class="row" style="margin-top: 10px">
                <button class="btn primary" id="btnReadChat">POST /linkedin/read-chat</button>
                <button class="btn primary" id="btnSendConnection">POST /linkedin/send-connection</button>
                <button class="btn" id="btnCopyJson">Copiar JSON</button>
                <button class="btn danger" id="btnClear">Limpiar</button>
            </div>

            <div style="margin-top: 10px">
                <pre id="out">{}</pre>
            </div>

            <div class="mutedline"></div>

            <div class="title" style="margin-top: 0">
                <span>Logs</span>
                <span class="subtle">últimos eventos del socket + HTTP</span>
            </div>
            <pre class="log" id="log"></pre>
        </div>

        <!-- RIGHT -->
        <div class="card">
            <div class="title">
                <span>Stream Viewer</span>
                <span class="subtle">Click en el stream para capturar teclado / mouse</span>
            </div>

            <div class="viewer" id="viewer">
                <img id="frame" alt="frame" />
                <div id="overlay" class="overlay" tabindex="0" aria-label="overlay"></div>
                <div class="hint">
                    Tip: click en el stream para focus. <br />
                    Enviar teclas: Enter/Esc/Backspace/Tab/Flechas.
                </div>
            </div>

            <div class="subtle" style="margin-top: 10px">
                El stream sirve para loguearte manualmente en LinkedIn y después probar <code>read-chat</code>.
            </div>
        </div>
    </div>

    <script>
        // ---------------------------
        // Helpers (NO storage)
        // ---------------------------
        const $ = (id) => document.getElementById(id);

        const logEl = $("log");
        const outEl = $("out");
        const frameEl = $("frame");
        const overlayEl = $("overlay");
        const viewerEl = $("viewer");

        const wsDot = $("wsDot");
        const wsStatus = $("wsStatus");
        const httpDot = $("httpDot");
        const httpStatus = $("httpStatus");
        const lastFrame = $("lastFrame");


        let socket = null;
        let lastImageTs = 0;

        // FIX: bloquear scroll del body mientras el stream esté "en foco"
        let streamFocused = false;
        let prevBodyOverflow = "";

        function lockPageScroll(on) {
            if (on) {
                prevBodyOverflow = document.body.style.overflow || "";
                document.body.style.overflow = "hidden";
            } else {
                document.body.style.overflow = prevBodyOverflow;
            }
        }

        function setStreamFocus(on) {
            if (streamFocused === on) return;
            streamFocused = on;
            viewerEl.classList.toggle("focused", on);
            lockPageScroll(on);
            appendLog(on ? "Stream focus ON (scroll bloqueado)" : "Stream focus OFF (scroll liberado)");
        }

        function now() {
            return new Date().toLocaleTimeString();
        }

        function appendLog(msg, obj) {
            const line = `[${now()}] ${msg}` + (obj ? `\n${safeJson(obj)}\n` : "\n");
            logEl.textContent = (line + logEl.textContent).slice(0, 12000);
        }

        function safeJson(v) {
            try {
                return JSON.stringify(v, null, 2);
            } catch {
                return String(v);
            }
        }

        function setWsState(state, extra) {
            if (state === "connected") {
                wsDot.className = "dot good";
                wsStatus.textContent = "WS: conectado" + (extra ? ` (${extra})` : "");
            } else if (state === "error") {
                wsDot.className = "dot bad";
                wsStatus.textContent = "WS: error" + (extra ? ` (${extra})` : "");
            } else {
                wsDot.className = "dot";
                wsStatus.textContent = "WS: desconectado";
            }
        }

        function setHttpState(state, extra) {
            if (state === "ok") {
                httpDot.className = "dot good";
                httpStatus.textContent = "HTTP: ok" + (extra ? ` (${extra})` : "");
            } else if (state === "error") {
                httpDot.className = "dot bad";
                httpStatus.textContent = "HTTP: error" + (extra ? ` (${extra})` : "");
            } else {
                httpDot.className = "dot";
                httpStatus.textContent = "HTTP: idle";
            }
        }

        function setConnHttpState(state, extra) {
            if (state === "ok") {
                connDot.className = "dot good";
                connStatus.textContent = "HTTP: ok" + (extra ? ` (${extra})` : "");
            } else if (state === "error") {
                connDot.className = "dot bad";
                connStatus.textContent = "HTTP: error" + (extra ? ` (${extra})` : "");
            } else {
                connDot.className = "dot";
                connStatus.textContent = "HTTP: idle";
            }
        }
        function getConfig() {
            const baseUrlRaw = $("baseUrl").value.trim() || "http://localhost:3001";
            const apiPrefixRaw = $("apiPrefix").value.trim() || "/api/zion";
            const sessionId = ($("sessionId").value.trim() || "default").trim();
            const fps = Math.max(1, Math.min(10, Number($("fps").value || 2)));

            // normalize
            const baseUrl = baseUrlRaw.replace(/\/+$/, "");
            let apiPrefix = apiPrefixRaw;
            if (!apiPrefix) apiPrefix = "";
            if (apiPrefix && !apiPrefix.startsWith("/")) apiPrefix = "/" + apiPrefix;
            apiPrefix = apiPrefix.replace(/\/+$/, "");

            const vpW = Math.max(1, Number($("vpW").value || 1280));
            const vpH = Math.max(1, Number($("vpH").value || 720));

            return { baseUrl, apiPrefix, sessionId, fps, vpW, vpH };
        }

        async function fetchJson(url, opts) {
            const res = await fetch(url, {
                ...opts,
                headers: {
                    "Content-Type": "application/json",
                    ...(opts && opts.headers ? opts.headers : {}),
                },
            });

            const text = await res.text();
            let data = null;
            try {
                data = text ? JSON.parse(text) : null;
            } catch {
                data = { raw: text };
            }

            if (!res.ok) {
                const err = new Error(`HTTP ${res.status}`);
                err.payload = data;
                throw err;
            }
            return data;
        }

        // ---------------------------
        // Socket / Stream
        // ---------------------------
        function connectSocket() {
            const { baseUrl, apiPrefix, sessionId, fps } = getConfig();

            if (socket) {
                try {
                    socket.disconnect();
                } catch { }
                socket = null;
            }

            const ns = `${baseUrl}${apiPrefix}/stream`;
            const sockPath = `${apiPrefix || ""}/socket.io`;

            appendLog("Conectando socket...", { ns, path: sockPath, sessionId, fps });

            socket = io(ns, {
                path: sockPath,
                transports: ["websocket"],
                reconnection: true,
                reconnectionAttempts: 20,
                reconnectionDelay: 500,
                query: { sessionId, fps },
            });

            socket.on("connect", () => {
                setWsState("connected", `id=${socket.id}`);
                appendLog("Socket conectado", { id: socket.id });
            });

            socket.on("disconnect", (reason) => {
                setWsState("disconnected");
                appendLog("Socket desconectado", { reason });
            });

            socket.on("connect_error", (err) => {
                setWsState("error", err?.message || "connect_error");
                appendLog("Socket connect_error", { message: err?.message, err });
            });

            socket.on("frame", ({ data, mimeType, ts }) => {
                lastImageTs = ts || Date.now();
                frameEl.src = `data:${mimeType};base64,${data}`;
                lastFrame.textContent = `Frame: ${new Date(lastImageTs).toLocaleTimeString()}`;
            });

            socket.on("frame_error", (payload) => {
                appendLog("frame_error", payload);
            });
        }

        function disconnectSocket() {
            if (!socket) return;
            try {
                socket.disconnect();
            } catch { }
            socket = null;
            setWsState("disconnected");
            appendLog("Socket manual disconnect");
        }

        function emitInput(ev) {
            if (!socket || !socket.connected) {
                appendLog("No WS conectado. Ignorando input.", ev);
                return;
            }
            socket.emit("input", ev, (ack) => {
                // log leve para no spamear
                if (ev.type === "cmd" || ev.type === "click") appendLog("ACK input", ack);
            });
        }

        // ---------------------------
        // Overlay -> inputs
        // ---------------------------
        let typingBuf = "";
        let typingTimer = null;

        function flushTyping() {
            if (!typingBuf) return;
            emitInput({ type: "type", text: typingBuf, delayMs: 0 });
            typingBuf = "";
        }

        function rectToRemoteXY(clientX, clientY) {
            const { vpW, vpH } = getConfig();
            const rect = overlayEl.getBoundingClientRect();
            const x01 = (clientX - rect.left) / Math.max(1, rect.width);
            const y01 = (clientY - rect.top) / Math.max(1, rect.height);
            const x = Math.round(x01 * vpW);
            const y = Math.round(y01 * vpH);
            return { x: Math.max(0, Math.min(vpW, x)), y: Math.max(0, Math.min(vpH, y)) };
        }

        // FIX: focus real + bloquear scroll body mientras está enfocado
        overlayEl.addEventListener("focus", () => setStreamFocus(true));
        overlayEl.addEventListener("blur", () => {
            flushTyping();
            setStreamFocus(false);
        });

        overlayEl.addEventListener("pointerdown", (e) => {
            // focus sin "saltar" el scroll
            overlayEl.focus({ preventScroll: true });
            setStreamFocus(true);

            const { x, y } = rectToRemoteXY(e.clientX, e.clientY);
            emitInput({ type: "down", x, y, button: "left" });
        });

        overlayEl.addEventListener("pointerup", (e) => {
            const { x, y } = rectToRemoteXY(e.clientX, e.clientY);
            emitInput({ type: "up", x, y, button: "left" });
            // "click" explícito ayuda a tener consistencia
            emitInput({ type: "click", x, y, button: "left", clickCount: 1 });
        });

        overlayEl.addEventListener(
            "wheel",
            (e) => {
                // FIX: evita scroll del navegador (page) mientras scrolleás el stream
                e.preventDefault();
                e.stopPropagation();
                emitInput({ type: "wheel", dx: e.deltaX, dy: e.deltaY });
            },
            { passive: false }
        );

        overlayEl.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });

        overlayEl.addEventListener("keydown", (e) => {
            // Evita que el browser haga scroll / shortcuts locales
            e.preventDefault();
            e.stopPropagation();

            const key = e.key;

            // Escape: salir del focus del stream (y liberar scroll)
            if (key === "Escape") {
                flushTyping();
                try {
                    overlayEl.blur();
                } catch { }
                setStreamFocus(false);
                emitInput({ type: "press", key: "Escape" });
                return;
            }

            // teclas especiales -> press
            const special = [
                "Enter",
                "Backspace",
                "Tab",
                "ArrowUp",
                "ArrowDown",
                "ArrowLeft",
                "ArrowRight",
                "PageUp",
                "PageDown",
                "Home",
                "End",
                "Delete",
            ];
            if (special.includes(key)) {
                flushTyping();
                emitInput({ type: "press", key });
                return;
            }

            // Ctrl/Meta/Alt combos -> press
            if (e.ctrlKey || e.metaKey || e.altKey) {
                flushTyping();
                const mods = [];
                if (e.altKey) mods.push("Alt");
                if (e.ctrlKey) mods.push("Control");
                if (e.metaKey) mods.push("Meta");
                if (e.shiftKey) mods.push("Shift");
                emitInput({ type: "press", key, modifiers: mods });
                return;
            }

            // texto normal -> buffer -> type
            if (key && key.length === 1) {
                typingBuf += key;
                clearTimeout(typingTimer);
                typingTimer = setTimeout(() => flushTyping(), 60);
            }
        });

        // FIX: click afuera del viewer => liberar focus/scroll
        document.addEventListener("pointerdown", (e) => {
            if (!streamFocused) return;
            const inside = viewerEl.contains(e.target);
            if (!inside) {
                try {
                    overlayEl.blur();
                } catch { }
                setStreamFocus(false);
            }
        });

        // ---------------------------
        // HTTP Actions
        // ---------------------------
        async function postOpen() {
            const { baseUrl, apiPrefix, sessionId } = getConfig();
            setHttpState("idle");
            const url = `${baseUrl}${apiPrefix}/linkedin/open`;

            setHttpState("ok", "open...");
            appendLog("POST /linkedin/open", { url, sessionId });

            try {
                const data = await fetchJson(url, {
                    method: "POST",
                    body: JSON.stringify({ sessionId }),
                });
                setHttpState("ok", "open ok");
                outEl.textContent = safeJson(data);
                appendLog("open response", data);
            } catch (e) {
                setHttpState("error", e.message);
                outEl.textContent = safeJson({ error: e.message, payload: e.payload || null });
                appendLog("open error", { message: e.message, payload: e.payload || null });
            }
        }

        async function postReadChat() {
            const { baseUrl, apiPrefix, sessionId } = getConfig();
            const profileUrl = $("profileUrl").value.trim();
            const limit = Number($("limit").value || 30);
            const threadHintRaw = $("threadHint").value.trim();

            const url = `${baseUrl}${apiPrefix}/linkedin/read-chat`;

            if (!profileUrl) {
                setHttpState("error", "profileUrl requerido");
                outEl.textContent = safeJson({ error: "profileUrl requerido" });
                return;
            }

            setHttpState("ok", "read-chat...");
            appendLog("POST /linkedin/read-chat", {
                url,
                sessionId,
                profileUrl,
                limit,
                threadHint: threadHintRaw || null,
            });

            const body = {
                sessionId,
                profileUrl,
                limit: Number.isFinite(limit) ? limit : 30,
            };
            if (threadHintRaw) body.threadHint = threadHintRaw;

            try {
                const data = await fetchJson(url, {
                    method: "POST",
                    body: JSON.stringify(body),
                });
                setHttpState("ok", "read-chat ok");
                outEl.textContent = safeJson(data);
                appendLog("read-chat response", data);
            } catch (e) {
                setHttpState("error", e.message);
                outEl.textContent = safeJson({ error: e.message, payload: e.payload || null });
                appendLog("read-chat error", { message: e.message, payload: e.payload || null });
            }
        }
  async function postSendConnection() {
  const { baseUrl, apiPrefix, sessionId } = getConfig();

  // ✅ reuse the existing input
  const profileUrl = $("profileUrl").value.trim();
  const noteRaw = $("connNote").value;

  const url = `${baseUrl}${apiPrefix}/linkedin/send-connection`;

  if (!profileUrl) {
    setHttpState("error", "profileUrl requerido");
    outEl.textContent = safeJson({ error: "profileUrl requerido" });
    return;
  }

  const body = { sessionId, profileUrl };
  // ✅ Only include note if non-empty to truly test “without note”
  if (noteRaw && noteRaw.trim()) body.note = noteRaw.trim();

  setHttpState("ok", "send-connection...");
  appendLog("POST /linkedin/send-connection", { url, body });

  try {
    const data = await fetchJson(url, {
      method: "POST",
      body: JSON.stringify(body),
    });

    setHttpState("ok", "send-connection ok");
    outEl.textContent = safeJson(data);
    appendLog("send-connection response", data);
  } catch (e) {
    setHttpState("error", e.message);
    outEl.textContent = safeJson({ error: e.message, payload: e.payload || null });
    appendLog("send-connection error", { message: e.message, payload: e.payload || null });
  }
}



        function cmdReload() {
            emitInput({ type: "cmd", command: "reload" });
        }

        function cmdListTabs() {
            emitInput({ type: "cmd", command: "listTabs" });
        }

        // ---------------------------
        // Wire UI
        // ---------------------------
        $("btnConnect").addEventListener("click", () => connectSocket());
        $("btnDisconnect").addEventListener("click", () => disconnectSocket());

        $("btnOpen").addEventListener("click", () => postOpen());
        $("btnReload").addEventListener("click", () => cmdReload());
        $("btnListTabs").addEventListener("click", () => cmdListTabs());

        $("btnReadChat").addEventListener("click", () => postReadChat());
        $("btnSendConnection").addEventListener("click", () => postSendConnection());



        $("btnClear").addEventListener("click", () => {
            outEl.textContent = "{}";
            appendLog("Limpiar output");
        });

        $("btnCopyJson").addEventListener("click", async () => {
            try {
                await navigator.clipboard.writeText(outEl.textContent || "");
                appendLog("JSON copiado al clipboard");
            } catch (e) {
                appendLog("No pude copiar JSON", { error: String(e) });
            }
        });
        async function fetchJson(url, opts) {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), 120000); // 2 min timeout

            let res;
            try {
                res = await fetch(url, {
                    mode: "cors",
                    signal: ctrl.signal,
                    ...opts,
                    headers: {
                        "Content-Type": "application/json",
                        ...(opts && opts.headers ? opts.headers : {}),
                    },
                });
            } finally {
                clearTimeout(t);
            }

            const ct = res.headers.get("content-type") || "";
            const text = await res.text();

            appendLog("HTTP response meta", {
                url,
                status: res.status,
                ok: res.ok,
                contentType: ct,
                preview: text?.slice(0, 500),
            });

            let data = null;
            try {
                data = text ? JSON.parse(text) : null;
            } catch {
                data = { raw: text };
            }

            if (!res.ok) {
                const err = new Error(`HTTP ${res.status}`);
                err.payload = data;
                throw err;
            }
            return data;
        }


        // Defaults: baseUrl = current origin si estás sirviendo desde el backend,
        // si no, queda placeholder.
        (function initDefaults() {
            const origin = window.location.origin;
            // Si estás en file:// no sirve. Live server suele ser localhost:5500.
            if (origin && origin.startsWith("http")) {
                $("baseUrl").value = "http://localhost:3001";
            } else {
                $("baseUrl").value = "http://localhost:3001";
            }
            $("apiPrefix").value = "/api/zion";
            appendLog("UI listo. No hay storage ni polling.");
            setWsState("disconnected");
            setHttpState("idle");
            setStreamFocus(false);
        })();
    </script>
</body>

</html>