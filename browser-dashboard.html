<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Session Dashboard</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .screen-overlay {
            position: absolute;
            inset: 0;
            cursor: crosshair;
            outline: none;
            /* avoids browser gestures hijacking touch/trackpad */
            touch-action: none;
        }

        .screen-viewer.focused {
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15);
        }

        .screen-hint {
            position: absolute;
            left: 10px;
            bottom: 10px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            font-size: 11px;
            padding: 6px 8px;
            border-radius: 6px;
            font-family: monospace;
            display: none;
        }

        .screen-viewer:not(.focused) .screen-hint {
            display: block;
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .controls {
            padding: 20px;
            background: white;
            margin: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .controls h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 400;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group label {
            font-weight: 500;
            min-width: 120px;
        }

        input,
        select,
        textarea {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s ease;
            flex: 1;
            max-width: 300px;
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
        }

        .btn-danger:hover {
            background: #c53030;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #38a169;
            color: white;
        }

        .btn-success:hover {
            background: #2f855a;
            transform: translateY(-1px);
        }

        .sessions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            padding: 0 20px 20px;
        }

        .session-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .session-card:hover {
            transform: translateY(-2px);
        }

        .session-header {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-id {
            font-weight: 500;
            font-size: 16px;
        }

        .session-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-active {
            background: #48bb78;
            color: white;
        }

        .status-inactive {
            background: #e53e3e;
            color: white;
        }

        .status-unknown {
            background: #ed8936;
            color: white;
        }

        .session-controls {
            padding: 15px 20px;
            background: #f8f9fa;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .session-controls button {
            flex: 1;
            min-width: 80px;
            font-size: 12px;
            padding: 8px 12px;
        }

        .screen-container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .screen-viewer {
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            overflow: hidden;
            max-width: 100%;
            background: #f7fafc;
            position: relative;
        }

        .screen-viewer img {
            max-width: 100%;
            height: auto;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }

        .screen-placeholder {
            width: 400px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #a0aec0;
            font-size: 16px;
            background: #f7fafc;
        }

        .linkedin-tasks {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
        }

        .linkedin-tasks h3 {
            color: #4a5568;
            margin-bottom: 15px;
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .task-form {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .task-form input,
        .task-form textarea {
            width: 100%;
            margin-bottom: 10px;
        }

        .task-form textarea {
            resize: vertical;
            min-height: 80px;
        }

        .logs {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
            max-height: 200px;
            overflow-y: auto;
        }

        .logs h3 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 500;
        }

        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }

        .log-info {
            background: #e6fffa;
            color: #38a169;
        }

        .log-error {
            background: #fed7d7;
            color: #e53e3e;
        }

        .log-warning {
            background: #fefcbf;
            color: #d69e2e;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-header h3 {
            color: #4a5568;
            margin: 0;
        }

        .connection-indicator {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .connected {
            background: #c6f6d5;
            color: #2f855a;
        }

        .disconnected {
            background: #fed7d7;
            color: #c53030;
        }

        .fps-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .sessions-grid {
                grid-template-columns: 1fr;
                padding: 0 10px 20px;
            }

            .controls {
                margin: 10px;
            }

            .control-group {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group label {
                min-width: auto;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üöÄ Browser Session Dashboard</h1>
        <div class="connection-indicator disconnected" id="connectionStatus">Disconnected</div>
    </div>

    <div class="controls">
        <h2>üéõÔ∏è Global Controls</h2>
        <div class="control-group">
            <label>Base URL:</label>
            <input type="text" id="baseUrl" value="http://localhost:3001" placeholder="http://localhost:3001">
            <button class="btn-primary" onclick="updateConnection()">Connect</button>
        </div>

        <div class="control-group">
            <label>New Session ID:</label>
            <input type="text" id="newSessionId" placeholder="session-name" maxlength="50">
            <button class="btn-success" onclick="createSession()">Create Session</button>
            <button class="btn-primary" onclick="refreshSessions()">Refresh All</button>
        </div>
    </div>

    <div class="sessions-grid" id="sessionsGrid">
        <!-- Sessions will be dynamically added here -->
    </div>

    <!-- Modal for editing tasks -->
    <div class="modal" id="taskModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">LinkedIn Task</h3>
            </div>
            <div id="modalBody">
                <!-- Modal content will be dynamically added -->
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="executeTask()">Execute</button>
                <button class="btn-danger" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Auto-detect base URL from current origin
        function detectBaseUrl() {
            const currentOrigin = window.location.origin;

            // If running from file:// protocol, default to localhost
            if (currentOrigin === 'null' || currentOrigin.startsWith('file://')) {
                return 'http://localhost:3001';
            }

            // If running from a web server, detect the API port
            // Try common development ports or use same origin
            const commonPorts = ['3001', '3000', '8080', '4000'];
            const currentPort = window.location.port;

            // If we're on a known dev port, try the API port
            if (currentPort && commonPorts.includes(currentPort)) {
                // If on 3000, try 3001; if on other ports, try 3001 first
                const apiPort = currentPort === '3000' ? '3001' : '3001';
                return `${window.location.protocol}//${window.location.hostname}:${apiPort}`;
            }

            // Otherwise use current origin (same server)
            return currentOrigin;
        }

        let baseUrl = '';
        let sessions = new Map(); // sessionId -> { socket, status, lastFrame, logs }
        let currentModalTask = null;
        let currentModalSession = null;

        // Initialize


        function updateConnection() {
            baseUrl = document.getElementById('baseUrl').value.trim().replace(/\/$/, '');
            document.getElementById('connectionStatus').textContent = 'Connecting...';
            document.getElementById('connectionStatus').className = 'connection-indicator disconnected';

            // Test connection
            fetch(`${baseUrl}/api/zion/linkedin/session-state`)
                .then(res => res.ok ? 'connected' : 'error')
                .catch(() => 'error')
                .then(status => {
                    const indicator = document.getElementById('connectionStatus');
                    if (status === 'connected') {
                        indicator.textContent = 'Connected';
                        indicator.className = 'connection-indicator connected';
                        refreshSessions();
                    } else {
                        indicator.textContent = 'Connection Failed';
                        indicator.className = 'connection-indicator disconnected';
                    }
                });
        }
        window.addEventListener('load', () => {
            updateConnection();
        });
        function createSession() {
            const sessionId = document.getElementById('newSessionId').value.trim();
            if (!sessionId) {
                alert('Please enter a session ID');
                return;
            }

            if (sessions.has(sessionId)) {
                alert('Session already exists');
                return;
            }

            // Create session entry
            sessions.set(sessionId, {
                socket: null,
                status: 'unknown',
                lastFrame: null,
                logs: []
            });

            renderSessions();
            document.getElementById('newSessionId').value = '';

            // Start the session by opening LinkedIn
            startSession(sessionId);
        }

        function refreshSessions() {
            // For now, just re-render existing sessions
            // In a real implementation, you might want to fetch session list from server
            renderSessions();
        }

        function renderSessions() {
            const grid = document.getElementById('sessionsGrid');
            grid.innerHTML = '';

            if (sessions.size === 0) {
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #a0aec0; font-size: 18px;">No active sessions. Create a session to get started.</div>';
                return;
            }

            sessions.forEach((sessionData, sessionId) => {
                const sessionCard = createSessionCard(sessionId, sessionData);
                grid.appendChild(sessionCard);
            });
        }

        function createSessionCard(sessionId, sessionData) {
            const card = document.createElement('div');
            card.className = 'session-card';
            card.id = `session-${sessionId}`;

            const statusClass = sessionData.status === 'active' ? 'status-active' :
                sessionData.status === 'inactive' ? 'status-inactive' : 'status-unknown';

            card.innerHTML = `
                <div class="session-header">
                    <div class="session-id">üì± ${sessionId}</div>
                    <div class="session-status ${statusClass}">${sessionData.status.toUpperCase()}</div>
                </div>
                
                <div class="session-controls">
                    <button class="btn-success" onclick="startSession('${sessionId}')">Start</button>
                    <button class="btn-primary" onclick="checkSessionState('${sessionId}')">Check State</button>
                    <button class="btn-danger" onclick="stopSession('${sessionId}')">Stop</button>
                    <button class="btn-danger" onclick="deleteSession('${sessionId}')">Delete</button>
                </div>

 <div class="screen-container">
  <div class="screen-viewer" id="screen-${sessionId}">
    <div class="screen-placeholder" id="placeholder-${sessionId}">
      Click "Start" to initialize session
    </div>

    <div class="screen-stage" id="stage-${sessionId}" style="display:none;">
      <img id="img-${sessionId}" alt="Browser Screen" draggable="false" />
      <div class="screen-overlay" id="overlay-${sessionId}" tabindex="0"
           title="Click to focus, then type. Scroll to scroll."></div>
      <div class="screen-hint">Click to focus ‚Ä¢ then type ‚Ä¢ scroll to scroll</div>
      <div class="fps-indicator" id="fps-${sessionId}" style="display:none;">0 FPS</div>
    </div>
  </div>
</div>



                <div class="linkedin-tasks">
                    <h3>üîó LinkedIn Actions</h3>
                    
                    <div class="task-form">
                        <input type="text" placeholder="Profile URL" id="profileUrl-${sessionId}">
                        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                            <button class="btn-primary" onclick="openTaskModal('${sessionId}', 'send-message')">Send Message</button>
                            <button class="btn-primary" onclick="openTaskModal('${sessionId}', 'send-connection')">Send Connection</button>
                            <button class="btn-success" onclick="checkConnection('${sessionId}')">Check Connection</button>
                            <button class="btn-success" onclick="openTaskModal('${sessionId}', 'read-chat')">Read Chat</button>
                        </div>
                    </div>
                </div>

                <div class="logs">
                    <h3>üìã Logs</h3>
                    <div id="logs-${sessionId}">
                        <div class="log-entry log-info">Session created</div>
                    </div>
                </div>
            `;

            return card;
        }

        function addLog(sessionId, message, type = 'info') {
            const sessionData = sessions.get(sessionId);
            if (!sessionData) return;

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, message, type };
            sessionData.logs.push(logEntry);

            // Keep only last 50 logs
            if (sessionData.logs.length > 50) {
                sessionData.logs = sessionData.logs.slice(-50);
            }

            // Update UI
            const logsContainer = document.getElementById(`logs-${sessionId}`);
            if (logsContainer) {
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry log-${type}`;
                logDiv.textContent = `[${timestamp}] ${message}`;
                logsContainer.appendChild(logDiv);
                logsContainer.scrollTop = logsContainer.scrollHeight;

                // Keep only last 50 in DOM too
                while (logsContainer.children.length > 50) {
                    logsContainer.removeChild(logsContainer.firstChild);
                }
            }
        }

        function startSession(sessionId) {
            addLog(sessionId, 'Starting session...', 'info');

            // First, start browser by opening LinkedIn
            fetch(`${baseUrl}/api/zion/linkedin/open`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId })
            })
                .then(res => res.json())
                .then(data => {
                    addLog(sessionId, 'Browser opened successfully', 'info');
                    updateSessionStatus(sessionId, 'active');

                    // Start streaming
                    startStreaming(sessionId);
                    setTimeout(() => setFocusedSession(sessionId), 250);
                })
                .catch(err => {
                    addLog(sessionId, `Failed to start browser: ${err.message}`, 'error');
                    updateSessionStatus(sessionId, 'inactive');
                });
        }

        function startStreaming(sessionId) {
            const sessionData = sessions.get(sessionId);
            if (!sessionData) return;

            // Disconnect existing socket
            if (sessionData.socket) {
                sessionData.socket.disconnect();
            }

            // Create new socket connection for this session
            const socket = io(`${baseUrl}/api/zion/stream`, {
                path: "/api/zion/socket.io",   // ‚úÖ clave
                query: { sessionId, fps: 2 },
                transports: ["websocket", "polling"],
            });


            sessionData.socket = socket;
            bindInteractiveOverlay(sessionId);

            let frameCount = 0;
            let lastFpsUpdate = Date.now();

            socket.on('connect', () => {
                addLog(sessionId, 'Stream connected', 'info');
                document.getElementById(`fps-${sessionId}`).style.display = 'block';
            });

            socket.on('frame', (data) => {
                frameCount++;
                const now = Date.now();

                // Update FPS every second
                if (now - lastFpsUpdate >= 1000) {
                    const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                    document.getElementById(`fps-${sessionId}`).textContent = `${fps} FPS`;
                    frameCount = 0;
                    lastFpsUpdate = now;
                }

                // Update screen
                const img = document.getElementById(`img-${sessionId}`);
                const stage = document.getElementById(`stage-${sessionId}`);  // ‚úÖ Get the stage div
                const placeholder = document.getElementById(`placeholder-${sessionId}`);

                if (img && stage) {
                    img.src = `data:${data.mimeType};base64,${data.data}`;

                    // First frame => show stage, hide placeholder
                    if (stage.style.display === 'none' || !stage.style.display) {  // ‚úÖ Check the stage, not img
                        stage.style.display = 'block';  // ‚úÖ Show the stage container
                        if (placeholder) placeholder.style.display = 'none';
                    }
                }

                sessionData.lastFrame = data;
            });
            socket.on('frame_error', (error) => {
                addLog(sessionId, `Stream error: ${error.message}`, 'error');
                const screenContainer = document.getElementById(`screen-${sessionId}`);
                if (screenContainer) {
                    screenContainer.innerHTML = `<div class="screen-placeholder">Stream Error: ${error.message}</div>`;
                }
            });

            socket.on('disconnect', () => {
                addLog(sessionId, 'Stream disconnected', 'warning');
                document.getElementById(`fps-${sessionId}`).style.display = 'none';
            });
        }

        function stopSession(sessionId) {
            addLog(sessionId, 'Stopping session...', 'info');

            fetch(`${baseUrl}/api/zion/linkedin/stop-session`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        addLog(sessionId, 'Session stopped successfully', 'info');
                        updateSessionStatus(sessionId, 'inactive');

                        // Disconnect streaming
                        const sessionData = sessions.get(sessionId);
                        if (sessionData && sessionData.socket) {
                            sessionData.socket.disconnect();
                            sessionData.socket = null;
                        }

                        // Clear screen
                        const screenContainer = document.getElementById(`screen-${sessionId}`);
                        if (screenContainer) {
                            screenContainer.innerHTML = '<div class="screen-placeholder">Session stopped</div>';
                        }
                    } else {
                        addLog(sessionId, `Failed to stop session: ${data.message}`, 'error');
                    }
                })
                .catch(err => {
                    addLog(sessionId, `Failed to stop session: ${err.message}`, 'error');
                });
        }

        function deleteSession(sessionId) {
            if (!confirm(`Delete session "${sessionId}"? This action cannot be undone.`)) {
                return;
            }

            // First stop the session
            stopSession(sessionId);

            // Remove from our local state
            sessions.delete(sessionId);

            // Remove from UI
            const sessionCard = document.getElementById(`session-${sessionId}`);
            if (sessionCard) {
                sessionCard.remove();
            }

            addLog(sessionId, 'Session deleted', 'warning');
        }

        function checkSessionState(sessionId) {
            addLog(sessionId, 'Checking session state...', 'info');

            fetch(`${baseUrl}/api/zion/linkedin/session-state?sessionId=${sessionId}`)
                .then(res => res.json())
                .then(data => {
                    const status = data.isLoggedIn ? 'logged in' : 'not logged in';
                    const confidence = data.confidence ? ` (${Math.round(data.confidence * 100)}% confident)` : '';
                    addLog(sessionId, `Session state: ${status}${confidence}`, 'info');

                    if (data.reason) {
                        addLog(sessionId, `Reason: ${data.reason}`, 'info');
                    }

                    updateSessionStatus(sessionId, data.isLoggedIn ? 'active' : 'inactive');
                })
                .catch(err => {
                    addLog(sessionId, `Failed to check session state: ${err.message}`, 'error');
                });
        }

        function updateSessionStatus(sessionId, status) {
            const sessionData = sessions.get(sessionId);
            if (sessionData) {
                sessionData.status = status;

                // Update UI
                const statusElement = document.querySelector(`#session-${sessionId} .session-status`);
                if (statusElement) {
                    statusElement.textContent = status.toUpperCase();
                    statusElement.className = `session-status ${status === 'active' ? 'status-active' :
                        status === 'inactive' ? 'status-inactive' : 'status-unknown'
                        }`;
                }
            }
        }

        function checkConnection(sessionId) {
            const profileUrl = document.getElementById(`profileUrl-${sessionId}`).value.trim();
            if (!profileUrl) {
                alert('Please enter a profile URL');
                return;
            }

            addLog(sessionId, 'Checking connection status...', 'info');

            fetch(`${baseUrl}/api/zion/linkedin/check-connection`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId, profileUrl })
            })
                .then(res => res.json())
                .then((data) => {
                    // data = { ok, result:boolean, status:'connected'|'pending'|'not_connected'|'unknown', pending:boolean, ... }

                    if (!data?.ok) {
                        addLog(sessionId, `check-connection failed: ${data?.executionDetails?.errors?.[0]?.message || 'unknown error'}`, 'error');
                        return;
                    }

                    const status = data.status || 'unknown';

                    const label =
                        status === 'connected' ? '‚úÖ Connected' :
                            status === 'pending' ? 'üü† Pending request' :
                                status === 'not_connected' ? '‚ùå Not connected' :
                                    '‚ö™ Unknown';

                    const logType =
                        status === 'connected' ? 'info' :
                            status === 'pending' ? 'warning' :
                                status === 'not_connected' ? 'warning' :
                                    'warning';

                    addLog(sessionId, `Connection status: ${label}`, logType);

                    // Si quer√©s ver se√±ales / confidence r√°pido:
                    const signals = data?.executionDetails?.openaiDetails?.parsed?.signals;
                    const conf = data?.executionDetails?.openaiDetails?.parsed?.confidence;

                    if (Array.isArray(signals) && signals.length) {
                        addLog(sessionId, `Signals: ${signals.slice(0, 8).join(', ')}`, 'info');
                    }
                    if (typeof conf === 'number') {
                        addLog(sessionId, `Confidence: ${Math.round(conf * 100)}%`, 'info');
                    }
                })

                .catch(err => {
                    addLog(sessionId, `Failed to check connection: ${err.message}`, 'error');
                });
        }

        function openTaskModal(sessionId, taskType) {
            currentModalSession = sessionId;
            currentModalTask = taskType;

            const modal = document.getElementById('taskModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');

            const profileUrl = document.getElementById(`profileUrl-${sessionId}`).value;

            title.textContent = `${taskType.replace('-', ' ').toUpperCase()} - ${sessionId}`;

            let bodyContent = `<input type="text" id="modalProfileUrl" placeholder="Profile URL" value="${profileUrl}" style="width: 100%; margin-bottom: 10px;">`;

            switch (taskType) {
                case 'send-message':
                    bodyContent += `<textarea id="modalMessage" placeholder="Message content..." style="width: 100%; height: 120px;"></textarea>`;
                    break;
                case 'send-connection':
                    bodyContent += `<textarea id="modalNote" placeholder="Connection note (optional)..." style="width: 100%; height: 80px;"></textarea>`;
                    break;
                case 'read-chat':
                    bodyContent += `
                        <input type="number" id="modalLimit" placeholder="Message limit (default: 30)" value="30" style="width: 100%; margin-bottom: 10px;">
                        <input type="text" id="modalThreadHint" placeholder="Thread hint (optional)" style="width: 100%;">
                    `;
                    break;
            }

            body.innerHTML = bodyContent;
            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('taskModal').classList.remove('active');
            currentModalTask = null;
            currentModalSession = null;
        }

        function executeTask() {
            if (!currentModalTask || !currentModalSession) return;

            const profileUrl = document.getElementById('modalProfileUrl').value.trim();
            if (!profileUrl) {
                alert('Please enter a profile URL');
                return;
            }

            let payload = { sessionId: currentModalSession, profileUrl };
            let endpoint = '';

            switch (currentModalTask) {
                case 'send-message':
                    const message = document.getElementById('modalMessage').value.trim();
                    if (!message) {
                        alert('Please enter a message');
                        return;
                    }
                    payload.message = message;
                    endpoint = 'send-message';
                    break;
                case 'send-connection':
                    const note = document.getElementById('modalNote').value.trim();
                    if (note) payload.note = note;
                    endpoint = 'send-connection';
                    break;
                case 'read-chat':
                    const limit = parseInt(document.getElementById('modalLimit').value) || 30;
                    const threadHint = document.getElementById('modalThreadHint').value.trim();
                    payload.limit = limit;
                    if (threadHint) payload.threadHint = threadHint;
                    endpoint = 'read-chat';
                    break;
                default:
                    alert('Unknown task type');
                    return;
            }

            addLog(currentModalSession, `Executing ${currentModalTask}...`, 'info');

            fetch(`${baseUrl}/api/zion/linkedin/${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(res => res.json())
                .then(data => {
                    addLog(currentModalSession, `${currentModalTask} completed successfully`, 'info');
                    if (data.result) {
                        addLog(currentModalSession, `Result: ${JSON.stringify(data.result).substring(0, 100)}...`, 'info');
                    }
                    closeModal();
                })
                .catch(err => {
                    addLog(currentModalSession, `${currentModalTask} failed: ${err.message}`, 'error');
                    closeModal();
                });
        }
        function normalizeKey(k) {
            // Playwright-friendly names
            if (k === ' ') return 'Space';
            if (k === 'Esc') return 'Escape';
            return k;
        }

        function modifiersFromEvent(e) {
            const mods = [];
            if (e.altKey) mods.push('Alt');
            if (e.ctrlKey) mods.push('Control');
            if (e.metaKey) mods.push('Meta');
            if (e.shiftKey) mods.push('Shift');
            return mods;
        }

        function toRemoteXY(sessionId, clientX, clientY) {
            const overlay = document.getElementById(`overlay-${sessionId}`);
            const img = document.getElementById(`img-${sessionId}`);
            if (!overlay || !img) return { x: 0, y: 0 };

            const r = overlay.getBoundingClientRect();
            const rx = (clientX - r.left) / r.width;
            const ry = (clientY - r.top) / r.height;

            const w = img.naturalWidth || r.width;
            const h = img.naturalHeight || r.height;

            const x = Math.max(0, Math.min(w - 1, Math.round(rx * w)));
            const y = Math.max(0, Math.min(h - 1, Math.round(ry * h)));
            return { x, y };
        }

        function setFocusedSession(sessionId) {
            // remove focus class from all
            sessions.forEach((_, sid) => {
                const screen = document.getElementById(`screen-${sid}`);
                if (screen) screen.classList.remove('focused');
            });

            const screen = document.getElementById(`screen-${sessionId}`);
            if (screen) screen.classList.add('focused');

            const overlay = document.getElementById(`overlay-${sessionId}`);
            if (overlay) overlay.focus();
        }

        function emitInput(sessionId, payload) {
            const s = sessions.get(sessionId);
            if (!s?.socket || !s.socket.connected) return;
            s.socket.emit('input', payload);
        }

        function bindInteractiveOverlay(sessionId) {
            const overlay = document.getElementById(`overlay-${sessionId}`);
            if (!overlay) return;

            // avoid double-binding
            if (overlay.dataset.bound === '1') return;
            overlay.dataset.bound = '1';

            let pointerDown = null; // { id, startX, startY, startT, button }
            let dragging = false;
            let sentDown = false;

            let lastMoveAt = 0;

            let lastClickAt = 0;
            let lastClickX = 0;
            let lastClickY = 0;

            function sendMove(x, y) {
                const now = Date.now();
                if (now - lastMoveAt < 25) return; // throttle
                lastMoveAt = now;
                emitInput(sessionId, { type: 'move', x, y });
            }

            overlay.addEventListener('pointerdown', (e) => {
                setFocusedSession(sessionId);

                overlay.setPointerCapture(e.pointerId);

                const { x, y } = toRemoteXY(sessionId, e.clientX, e.clientY);
                pointerDown = {
                    id: e.pointerId,
                    startX: x,
                    startY: y,
                    startT: Date.now(),
                    button: e.button, // 0 left, 1 middle, 2 right
                };
                dragging = false;
                sentDown = false;

                // Prevent selecting/dragging
                e.preventDefault();
            });

            overlay.addEventListener('pointermove', (e) => {
                const { x, y } = toRemoteXY(sessionId, e.clientX, e.clientY);

                // hover move (important for menus / hover states)
                if (!pointerDown) {
                    sendMove(x, y);
                    return;
                }

                // if pointer down, decide drag vs click
                const dx = x - pointerDown.startX;
                const dy = y - pointerDown.startY;
                const dist = Math.hypot(dx, dy);

                if (!dragging && dist > 3) {
                    dragging = true;
                }

                if (dragging) {
                    if (!sentDown) {
                        sentDown = true;
                        emitInput(sessionId, {
                            type: 'down',
                            x: pointerDown.startX,
                            y: pointerDown.startY,
                            button: pointerDown.button === 2 ? 'right' : pointerDown.button === 1 ? 'middle' : 'left',
                            modifiers: modifiersFromEvent(e),
                        });
                    }
                    sendMove(x, y);
                } else {
                    // tiny movement: still allow hover
                    sendMove(x, y);
                }

                e.preventDefault();
            });

            overlay.addEventListener('pointerup', (e) => {
                const { x, y } = toRemoteXY(sessionId, e.clientX, e.clientY);

                if (!pointerDown) return;

                if (dragging) {
                    emitInput(sessionId, {
                        type: 'up',
                        x,
                        y,
                        button: pointerDown.button === 2 ? 'right' : pointerDown.button === 1 ? 'middle' : 'left',
                        modifiers: modifiersFromEvent(e),
                    });
                } else {
                    // click / double click
                    const now = Date.now();
                    const near =
                        Math.hypot(x - lastClickX, y - lastClickY) < 6 &&
                        (now - lastClickAt) < 320;

                    const clickCount = near ? 2 : 1;

                    if (clickCount === 2) {
                        lastClickAt = 0;
                    } else {
                        lastClickAt = now;
                        lastClickX = x;
                        lastClickY = y;
                    }

                    emitInput(sessionId, {
                        type: 'click',
                        x,
                        y,
                        button: pointerDown.button === 2 ? 'right' : pointerDown.button === 1 ? 'middle' : 'left',
                        clickCount,
                        modifiers: modifiersFromEvent(e),
                    });
                }

                pointerDown = null;
                dragging = false;
                sentDown = false;

                e.preventDefault();
            });

            overlay.addEventListener('contextmenu', (e) => {
                // prevent browser menu
                e.preventDefault();
            });

            overlay.addEventListener('wheel', (e) => {
                setFocusedSession(sessionId);
                e.preventDefault();
                emitInput(sessionId, { type: 'wheel', dx: e.deltaX, dy: e.deltaY });
            }, { passive: false });

            // Keyboard goes to the focused overlay (no global key handler needed)
            overlay.addEventListener('keydown', (e) => {
                // Don‚Äôt hijack typing in your modal/inputs elsewhere
                const tag = (document.activeElement?.tagName || '').toLowerCase();
                if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

                const mods = modifiersFromEvent(e);

                if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                    emitInput(sessionId, { type: 'type', text: e.key });
                    e.preventDefault();
                    return;
                }

                emitInput(sessionId, { type: 'press', key: normalizeKey(e.key), modifiers: mods });
                e.preventDefault();
            });

            overlay.addEventListener('paste', (e) => {
                const text = e.clipboardData?.getData('text') || '';
                if (text) {
                    emitInput(sessionId, { type: 'type', text });
                    e.preventDefault();
                }
            });
        }

        // Initialize with default session
        window.addEventListener('load', () => {
            // Auto-create a default session
            setTimeout(() => {
                document.getElementById('newSessionId').value = 'default';
                createSession();
            }, 1000);
        });
    </script>
</body>

</html>