<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sales Navigator Debug (Send + Read Chat)</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        :root {
            --bg: #0b1020;
            --panel: rgba(255, 255, 255, 0.06);
            --border: rgba(255, 255, 255, 0.12);
            --text: rgba(255, 255, 255, 0.92);
            --muted: rgba(255, 255, 255, 0.65);
            --good: #40c463;
            --bad: #ff5c5c;
            --warn: #f7b955;
            --accent: #8b5cf6;
        }

        * {
            box-sizing: border-box;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 600px at 20% 10%, rgba(139, 92, 246, 0.25), transparent 60%),
                radial-gradient(900px 500px at 80% 20%, rgba(59, 130, 246, 0.18), transparent 55%),
                var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        .wrap {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 16px;
            padding: 16px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
        }

        .title {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.2px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 0 0 10px 0;
        }

        .subtle {
            color: var(--muted);
            font-size: 12px;
            line-height: 1.4;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        label {
            font-size: 12px;
            color: var(--muted);
            display: block;
            margin-bottom: 6px;
        }

        input,
        textarea {
            width: 100%;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 10px;
            outline: none;
        }

        textarea {
            min-height: 92px;
            resize: vertical;
        }

        input:focus,
        textarea:focus {
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.15);
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            appearance: none;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            padding: 9px 11px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 650;
            font-size: 12px;
            transition: transform 0.05s ease, background 0.15s ease, border-color 0.15s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(139, 92, 246, 0.5);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.primary {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.55);
        }

        .btn.danger {
            background: rgba(255, 92, 92, 0.15);
            border-color: rgba(255, 92, 92, 0.45);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.18);
            font-size: 12px;
            color: var(--muted);
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: var(--warn);
            box-shadow: 0 0 0 4px rgba(247, 185, 85, 0.15);
        }

        .dot.good {
            background: var(--good);
            box-shadow: 0 0 0 4px rgba(64, 196, 99, 0.15);
        }

        .dot.bad {
            background: var(--bad);
            box-shadow: 0 0 0 4px rgba(255, 92, 92, 0.15);
        }

        .viewer {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.35);
            aspect-ratio: 16 / 9;
            max-height: 78vh;
        }

        .viewer.focused {
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.15);
        }

        .viewer img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        .overlay {
            position: absolute;
            inset: 0;
            outline: none;
            cursor: crosshair;
            touch-action: none;
        }

        .hint {
            position: absolute;
            left: 12px;
            bottom: 12px;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 8px 10px;
            border-radius: 12px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.85);
        }

        pre {
            margin: 0;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 10px;
            overflow: auto;
            max-height: 310px;
            font-size: 12px;
            line-height: 1.35;
        }

        .log {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.78);
            white-space: pre-wrap;
        }

        .mutedline {
            height: 1px;
            background: rgba(255, 255, 255, 0.08);
            margin: 12px 0;
        }

        /* ‚úÖ Chat preview (rendered) */
        .chat {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 10px;
            max-height: 280px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .msg {
            max-width: 92%;
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: 14px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.06);
        }

        .msg.me {
            align-self: flex-end;
            background: rgba(139, 92, 246, 0.14);
            border-color: rgba(139, 92, 246, 0.35);
        }

        .msg.other {
            align-self: flex-start;
            background: rgba(59, 130, 246, 0.10);
            border-color: rgba(59, 130, 246, 0.28);
        }

        .msg .meta {
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 4px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .msg .text {
            font-size: 12px;
            white-space: pre-wrap;
            line-height: 1.35;
            color: rgba(255, 255, 255, 0.88);
        }

        .kbadge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.22);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.78);
        }

        @media (max-width: 980px) {
            .wrap {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <!-- LEFT -->
        <div class="card">
            <div class="title">
                <span>Config (sin storage)</span>
                <span class="pill"><span id="wsDot" class="dot"></span><span id="wsStatus">WS:
                        desconectado</span></span>
            </div>

            <div class="grid">
                <div>
                    <label>Backend Base URL</label>
                    <input id="baseUrl" placeholder="http://localhost:3001" />
                    <div class="subtle" style="margin-top: 6px">
                        Si abr√≠s este HTML con Live Server (5500), pon√© ac√° tu backend (ej: http://localhost:3001).
                    </div>
                </div>
                <div>
                    <label>API Prefix</label>
                    <input id="apiPrefix" placeholder="/api/zion" />
                    <div class="subtle" style="margin-top: 6px">
                        Tu Socket Gateway usa <code>/api/zion</code>. Si no ten√©s prefijo global, dejalo vac√≠o.
                    </div>
                </div>

                <div>
                    <label>Session ID (no persistido)</label>
                    <input id="sessionId" value="default" />
                </div>

                <div>
                    <label>FPS (1-10)</label>
                    <input id="fps" type="number" min="1" max="10" value="2" />
                </div>

                <div>
                    <label>Viewport remoto (para mapear clicks)</label>
                    <div class="row">
                        <input id="vpW" type="number" value="1280" style="width: 48%" />
                        <input id="vpH" type="number" value="720" style="width: 48%" />
                    </div>
                </div>

                <div>
                    <label>Acciones</label>
                    <div class="row">
                        <button class="btn primary" id="btnConnect">Conectar stream</button>
                        <button class="btn" id="btnDisconnect">Desconectar</button>
                    </div>
                </div>
            </div>

            <div class="mutedline"></div>

            <div class="title" style="margin-top: 0">
                <span>LinkedIn</span>
                <span class="pill"><span class="dot good" style="opacity: 0.85"></span><span id="lastFrame">Frame:
                        -</span></span>
            </div>

            <div class="row">
                <button class="btn primary" id="btnOpen">POST /linkedin/open</button>
                <button class="btn" id="btnReload">CMD reload</button>
                <button class="btn" id="btnListTabs">CMD listTabs</button>
            </div>

            <div class="subtle" style="margin-top: 10px">
                Us√° el stream para loguearte manualmente. Luego prob√° <code>read-salesnav-chat</code> (o
                <code>send-salesnav-message</code>).
            </div>

            <div class="mutedline"></div>

            <div class="title" style="margin-top: 0">
                <span>Sales Navigator ¬∑ Send Message</span>
                <span class="pill"><span class="dot" id="httpDot"></span><span id="httpStatus">HTTP: idle</span></span>
            </div>

            <div>
                <label>profileUrl</label>
                <input id="snProfileUrl" placeholder="https://www.linkedin.com/in/..." />
                <div class="subtle" style="margin-top: 6px">
                    Tip: pod√©s pegar el perfil normal (<code>/in/</code>). Tu backend ya abre SN v√≠a overflow ‚ÄúView in
                    Sales Navigator‚Äù.
                </div>
            </div>

            <div class="grid" style="margin-top: 10px">
                <div>
                    <label>subject (opcional)</label>
                    <input id="snSubject" placeholder="Asunto (si aparece en la UI)" />
                </div>
                <div>
                    <label>Acci√≥n</label>
                    <button class="btn primary" id="btnSendSalesNavMessage" style="width:100%">
                        POST /linkedin/send-salesnav-message
                    </button>
                </div>
            </div>

            <div style="margin-top: 10px">
                <label>message</label>
                <textarea id="snMessage" placeholder="Escrib√≠ el mensaje..."></textarea>
            </div>

            <div class="row" style="margin-top: 10px">
                <button class="btn" id="btnCopySendSalesNavBody">Copiar JSON (Send)</button>
                <button class="btn" id="btnCopyJson">Copiar JSON (Output)</button>
                <button class="btn danger" id="btnClear">Limpiar</button>
            </div>

            <div class="mutedline"></div>

            <!-- ‚úÖ NEW: SalesNav Read Chat -->
            <div class="title" style="margin-top: 0">
                <span>Sales Navigator ¬∑ Read Chat</span>
                <span class="pill"><span class="dot" id="snReadDot"></span><span id="snReadStatus">ReadChat:
                        idle</span></span>
            </div>

            <div>
                <label>profileUrl</label>
                <input id="snReadProfileUrl" placeholder="https://www.linkedin.com/in/..." />
                <div class="subtle" style="margin-top: 6px">
                    Este endpoint abre Sales Navigator, click en ‚ÄúMessage‚Äù, carga historial y extrae mensajes (hora +
                    rol).
                </div>
            </div>

            <div class="grid" style="margin-top: 10px">
                <div>
                    <label>limit (1-200)</label>
                    <input id="snReadLimit" type="number" min="1" max="200" value="30" />
                </div>
                <div>
                    <label>threadHint (opcional)</label>
                    <input id="snReadThreadHint" placeholder="Ej: nombre o pista del thread" />
                </div>
            </div>

            <div class="grid" style="margin-top: 10px">
                <div>
                    <label>taskId (opcional UUID v4)</label>
                    <input id="snReadTaskId" placeholder="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx" />
                </div>
                <div>
                    <label>Acci√≥n</label>
                    <button class="btn primary" id="btnReadSalesNavChat" style="width:100%">
                        POST /linkedin/read-salesnav-chat
                    </button>
                </div>
            </div>

            <div class="row" style="margin-top: 10px">
                <button class="btn" id="btnCopyReadSalesNavBody">Copiar JSON (Read)</button>
                <button class="btn" id="btnSyncProfileUrl">Copiar profileUrl desde Send ‚Üí Read</button>
            </div>

            <div style="margin-top: 10px">
                <label>Chat preview (rendered)</label>
                <div id="chatPreview" class="chat">
                    <div class="subtle">Todav√≠a no hay resultados. Ejecut√° <code>read-salesnav-chat</code>.</div>
                </div>
            </div>

            <div class="mutedline"></div>

            <!-- Output -->
            <div class="title" style="margin-top: 0">
                <span>Output (√∫ltima respuesta)</span>
                <span class="subtle">raw JSON</span>
            </div>
            <div style="margin-top: 10px">
                <pre id="out">{}</pre>
            </div>

            <div class="mutedline"></div>

            <div class="title" style="margin-top: 0">
                <span>Warm Up ¬∑ Watch New Messages</span>
                <span class="pill"><span class="dot" id="warmDot"></span><span id="warmStatus">WarmUp:
                        idle</span></span>
            </div>

            <div>
                <label>linkedinUrl (perfil)</label>
                <input id="warmLinkedinUrl" placeholder="https://www.linkedin.com/in/..." />
                <div class="subtle" style="margin-top: 6px">
                    Se abre una tab nueva y se monitorea si aparece un mensaje distinto a <code>lastMessageStr</code>.
                </div>
            </div>

            <div style="margin-top: 10px">
                <label>lastMessageStr (√∫ltimo mensaje conocido)</label>
                <textarea id="warmLastMessageStr" placeholder="Peg√° ac√° el √∫ltimo mensaje que viste..."></textarea>
            </div>

            <div class="row" style="margin-top: 10px">
                <button class="btn primary" id="btnStartWarmUp">POST /linkedin/start-warm-up</button>
                <button class="btn" id="btnCopyWarmUpBody">Copiar JSON (WarmUp)</button>
            </div>

            <div class="subtle" style="margin-top: 10px">
                Nota: si tu DTO usa <code>profileUrl</code> en vez de <code>linkedinUrl</code>, cambi√° el nombre en el
                body del fetch.
            </div>

            <div class="mutedline"></div>

            <div class="title" style="margin-top: 0">
                <span>Logs</span>
                <span class="subtle">√∫ltimos eventos del socket + HTTP</span>
            </div>
            <pre class="log" id="log"></pre>
        </div>

        <!-- RIGHT -->
        <div class="card">
            <div class="title">
                <span>Stream Viewer</span>
                <span class="subtle">Click en el stream para capturar teclado / mouse</span>
            </div>

            <div class="viewer" id="viewer">
                <img id="frame" alt="frame" />
                <div id="overlay" class="overlay" tabindex="0" aria-label="overlay"></div>
                <div class="hint">
                    Tip: click en el stream para focus. <br />
                    Enviar teclas: Enter/Esc/Backspace/Tab/Flechas.
                </div>
            </div>

            <div class="subtle" style="margin-top: 10px">
                El stream sirve para loguearte manualmente y ver qu√© est√° haciendo el bot.
            </div>
        </div>
    </div>

    <script>
        // ---------------------------
        // Helpers (NO storage)
        // ---------------------------
        const $ = (id) => document.getElementById(id);

        const logEl = $("log");
        const outEl = $("out");
        const frameEl = $("frame");
        const overlayEl = $("overlay");
        const viewerEl = $("viewer");

        const wsDot = $("wsDot");
        const wsStatus = $("wsStatus");
        const httpDot = $("httpDot");
        const httpStatus = $("httpStatus");
        const lastFrame = $("lastFrame");

        const warmDot = $("warmDot");
        const warmStatus = $("warmStatus");

        const snReadDot = $("snReadDot");
        const snReadStatus = $("snReadStatus");
        const chatPreviewEl = $("chatPreview");

        let socket = null;
        let lastImageTs = 0;

        // FIX: bloquear scroll del body mientras el stream est√© "en foco"
        let streamFocused = false;
        let prevBodyOverflow = "";

        function now() {
            return new Date().toLocaleTimeString();
        }

        function safeJson(v) {
            try { return JSON.stringify(v, null, 2); }
            catch { return String(v); }
        }

        function appendLog(msg, obj) {
            const line = `[${now()}] ${msg}` + (obj ? `\n${safeJson(obj)}\n` : "\n");
            logEl.textContent = (line + logEl.textContent).slice(0, 12000);
        }

        function lockPageScroll(on) {
            if (on) {
                prevBodyOverflow = document.body.style.overflow || "";
                document.body.style.overflow = "hidden";
            } else {
                document.body.style.overflow = prevBodyOverflow;
            }
        }

        function setStreamFocus(on) {
            if (streamFocused === on) return;
            streamFocused = on;
            viewerEl.classList.toggle("focused", on);
            lockPageScroll(on);
            appendLog(on ? "Stream focus ON (scroll bloqueado)" : "Stream focus OFF (scroll liberado)");
        }

        function setWsState(state, extra) {
            if (state === "connected") {
                wsDot.className = "dot good";
                wsStatus.textContent = "WS: conectado" + (extra ? ` (${extra})` : "");
            } else if (state === "error") {
                wsDot.className = "dot bad";
                wsStatus.textContent = "WS: error" + (extra ? ` (${extra})` : "");
            } else {
                wsDot.className = "dot";
                wsStatus.textContent = "WS: desconectado";
            }
        }

        function setHttpState(state, extra) {
            if (state === "ok") {
                httpDot.className = "dot good";
                httpStatus.textContent = "HTTP: ok" + (extra ? ` (${extra})` : "");
            } else if (state === "error") {
                httpDot.className = "dot bad";
                httpStatus.textContent = "HTTP: error" + (extra ? ` (${extra})` : "");
            } else {
                httpDot.className = "dot";
                httpStatus.textContent = "HTTP: idle";
            }
        }

        function setWarmState(state, extra) {
            if (state === "ok") {
                warmDot.className = "dot good";
                warmStatus.textContent = "WarmUp: ok" + (extra ? ` (${extra})` : "");
            } else if (state === "error") {
                warmDot.className = "dot bad";
                warmStatus.textContent = "WarmUp: error" + (extra ? ` (${extra})` : "");
            } else if (state === "running") {
                warmDot.className = "dot";
                warmStatus.textContent = "WarmUp: running" + (extra ? ` (${extra})` : "");
            } else {
                warmDot.className = "dot";
                warmStatus.textContent = "WarmUp: idle";
            }
        }

        function setSnReadState(state, extra) {
            if (state === "ok") {
                snReadDot.className = "dot good";
                snReadStatus.textContent = "ReadChat: ok" + (extra ? ` (${extra})` : "");
            } else if (state === "error") {
                snReadDot.className = "dot bad";
                snReadStatus.textContent = "ReadChat: error" + (extra ? ` (${extra})` : "");
            } else if (state === "running") {
                snReadDot.className = "dot";
                snReadStatus.textContent = "ReadChat: running" + (extra ? ` (${extra})` : "");
            } else {
                snReadDot.className = "dot";
                snReadStatus.textContent = "ReadChat: idle";
            }
        }

        function getConfig() {
            const baseUrlRaw = $("baseUrl").value.trim() || "http://localhost:3001";
            const apiPrefixRaw = $("apiPrefix").value.trim() || "/api/zion";
            const sessionId = ($("sessionId").value.trim() || "default").trim();
            const fps = Math.max(1, Math.min(10, Number($("fps").value || 2)));

            // normalize
            const baseUrl = baseUrlRaw.replace(/\/+$/, "");
            let apiPrefix = apiPrefixRaw;
            if (!apiPrefix) apiPrefix = "";
            if (apiPrefix && !apiPrefix.startsWith("/")) apiPrefix = "/" + apiPrefix;
            apiPrefix = apiPrefix.replace(/\/+$/, "");

            const vpW = Math.max(1, Number($("vpW").value || 1280));
            const vpH = Math.max(1, Number($("vpH").value || 720));

            return { baseUrl, apiPrefix, sessionId, fps, vpW, vpH };
        }

        async function fetchJson(url, opts, timeoutMs = 120000) {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeoutMs);

            let res;
            try {
                res = await fetch(url, {
                    mode: "cors",
                    signal: ctrl.signal,
                    ...opts,
                    headers: {
                        "Content-Type": "application/json",
                        ...(opts && opts.headers ? opts.headers : {}),
                    },
                });
            } finally {
                clearTimeout(t);
            }

            const ct = res.headers.get("content-type") || "";
            const text = await res.text();

            appendLog("HTTP response meta", {
                url,
                status: res.status,
                ok: res.ok,
                contentType: ct,
                preview: text?.slice(0, 500),
            });

            let data = null;
            try { data = text ? JSON.parse(text) : null; }
            catch { data = { raw: text }; }

            if (!res.ok) {
                const err = new Error(`HTTP ${res.status}`);
                err.payload = data;
                throw err;
            }
            return data;
        }

        // ---------------------------
        // Socket / Stream
        // ---------------------------
        function connectSocket() {
            const { baseUrl, apiPrefix, sessionId, fps } = getConfig();

            if (socket) {
                try { socket.disconnect(); } catch { }
                socket = null;
            }

            const ns = `${baseUrl}${apiPrefix}/stream`;
            const sockPath = `${apiPrefix || ""}/socket.io`;

            appendLog("Conectando socket...", { ns, path: sockPath, sessionId, fps });

            socket = io(ns, {
                path: sockPath,
                transports: ["websocket"],
                reconnection: true,
                reconnectionAttempts: 20,
                reconnectionDelay: 500,
                query: { sessionId, fps },
            });

            socket.on("connect", () => {
                setWsState("connected", `id=${socket.id}`);
                appendLog("Socket conectado", { id: socket.id });
            });

            socket.on("disconnect", (reason) => {
                setWsState("disconnected");
                appendLog("Socket desconectado", { reason });
            });

            socket.on("connect_error", (err) => {
                setWsState("error", err?.message || "connect_error");
                appendLog("Socket connect_error", { message: err?.message, err });
            });

            socket.on("frame", ({ data, mimeType, ts }) => {
                lastImageTs = ts || Date.now();
                frameEl.src = `data:${mimeType};base64,${data}`;
                lastFrame.textContent = `Frame: ${new Date(lastImageTs).toLocaleTimeString()}`;
            });

            socket.on("frame_error", (payload) => {
                appendLog("frame_error", payload);
            });
        }

        function disconnectSocket() {
            if (!socket) return;
            try { socket.disconnect(); } catch { }
            socket = null;
            setWsState("disconnected");
            appendLog("Socket manual disconnect");
        }

        function emitInput(ev) {
            if (!socket || !socket.connected) {
                appendLog("No WS conectado. Ignorando input.", ev);
                return;
            }
            socket.emit("input", ev, (ack) => {
                if (ev.type === "cmd" || ev.type === "click") appendLog("ACK input", ack);
            });
        }

        // ---------------------------
        // Overlay -> inputs
        // ---------------------------
        let typingBuf = "";
        let typingTimer = null;

        function flushTyping() {
            if (!typingBuf) return;
            emitInput({ type: "type", text: typingBuf, delayMs: 0 });
            typingBuf = "";
        }

        function rectToRemoteXY(clientX, clientY) {
            const { vpW, vpH } = getConfig();
            const rect = overlayEl.getBoundingClientRect();
            const x01 = (clientX - rect.left) / Math.max(1, rect.width);
            const y01 = (clientY - rect.top) / Math.max(1, rect.height);
            const x = Math.round(x01 * vpW);
            const y = Math.round(y01 * vpH);
            return { x: Math.max(0, Math.min(vpW, x)), y: Math.max(0, Math.min(vpH, y)) };
        }

        overlayEl.addEventListener("focus", () => setStreamFocus(true));
        overlayEl.addEventListener("blur", () => {
            flushTyping();
            setStreamFocus(false);
        });

        overlayEl.addEventListener("pointerdown", (e) => {
            overlayEl.focus({ preventScroll: true });
            setStreamFocus(true);

            const { x, y } = rectToRemoteXY(e.clientX, e.clientY);
            emitInput({ type: "down", x, y, button: "left" });
        });

        overlayEl.addEventListener("pointerup", (e) => {
            const { x, y } = rectToRemoteXY(e.clientX, e.clientY);
            emitInput({ type: "up", x, y, button: "left" });
            emitInput({ type: "click", x, y, button: "left", clickCount: 1 });
        });

        overlayEl.addEventListener("wheel", (e) => {
            e.preventDefault();
            e.stopPropagation();
            emitInput({ type: "wheel", dx: e.deltaX, dy: e.deltaY });
        }, { passive: false });

        overlayEl.addEventListener("contextmenu", (e) => e.preventDefault());

        overlayEl.addEventListener("keydown", (e) => {
            e.preventDefault();
            e.stopPropagation();

            const key = e.key;

            if (key === "Escape") {
                flushTyping();
                try { overlayEl.blur(); } catch { }
                setStreamFocus(false);
                emitInput({ type: "press", key: "Escape" });
                return;
            }

            const special = [
                "Enter", "Backspace", "Tab",
                "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight",
                "PageUp", "PageDown", "Home", "End", "Delete",
            ];
            if (special.includes(key)) {
                flushTyping();
                emitInput({ type: "press", key });
                return;
            }

            if (e.ctrlKey || e.metaKey || e.altKey) {
                flushTyping();
                const mods = [];
                if (e.altKey) mods.push("Alt");
                if (e.ctrlKey) mods.push("Control");
                if (e.metaKey) mods.push("Meta");
                if (e.shiftKey) mods.push("Shift");
                emitInput({ type: "press", key, modifiers: mods });
                return;
            }

            if (key && key.length === 1) {
                typingBuf += key;
                clearTimeout(typingTimer);
                typingTimer = setTimeout(() => flushTyping(), 60);
            }
        });

        document.addEventListener("pointerdown", (e) => {
            if (!streamFocused) return;
            const inside = viewerEl.contains(e.target);
            if (!inside) {
                try { overlayEl.blur(); } catch { }
                setStreamFocus(false);
            }
        });

        // ---------------------------
        // Chat preview rendering (SalesNav read-chat)
        // ---------------------------
        function clearChatPreview(msg) {
            chatPreviewEl.innerHTML = "";
            const d = document.createElement("div");
            d.className = "subtle";
            d.textContent = msg || "Sin datos";
            chatPreviewEl.appendChild(d);
        }

        function extractMessagesFromResponse(resp) {
            const candidates = [
                resp?.data?.messages,
                resp?.data?.data?.messages,
                resp?.toolResult?.messages,
                resp?.toolResult?.data?.messages,
                resp?.messages,
            ];
            for (const arr of candidates) {
                if (Array.isArray(arr)) return arr;
            }
            return [];
        }

        function extractParticipantsFromResponse(resp) {
            return (
                resp?.data?.data?.participants ||
                resp?.data?.participants ||
                resp?.toolResult?.data?.participants ||
                resp?.toolResult?.participants ||
                null
            );
        }

        function renderChatPreview(resp) {
            const msgs = extractMessagesFromResponse(resp);
            const participants = extractParticipantsFromResponse(resp);

            chatPreviewEl.innerHTML = "";

            // Header badges
            const header = document.createElement("div");
            header.style.display = "flex";
            header.style.gap = "8px";
            header.style.flexWrap = "wrap";
            header.style.marginBottom = "4px";

            const b1 = document.createElement("div");
            b1.className = "kbadge";
            b1.textContent = `Mensajes: ${msgs.length}`;
            header.appendChild(b1);

            if (participants?.me || participants?.other) {
                const b2 = document.createElement("div");
                b2.className = "kbadge";
                b2.textContent = `Me: ${participants?.me || "?"} ¬∑ Other: ${participants?.other || "?"}`;
                header.appendChild(b2);
            }

            chatPreviewEl.appendChild(header);

            if (!msgs.length) {
                const empty = document.createElement("div");
                empty.className = "subtle";
                empty.textContent = "No se detectaron mensajes en el DOM (o el extractor devolvi√≥ 0).";
                chatPreviewEl.appendChild(empty);
                return;
            }

            for (const m of msgs) {
                const role = (m?.role || "").toString().toLowerCase();
                const isMe = role === "recruiter" || role === "you" || role === "me";

                const item = document.createElement("div");
                item.className = "msg " + (isMe ? "me" : "other");

                const meta = document.createElement("div");
                meta.className = "meta";

                const who = document.createElement("span");
                who.textContent = (isMe ? "You" : (m?.senderName || "Other"));
                meta.appendChild(who);

                const when = document.createElement("span");
                const timePart = m?.time ? `‚è± ${m.time}` : "";
                const dtPart = m?.datetime ? `üóì ${m.datetime}` : "";
                when.textContent = [timePart, dtPart].filter(Boolean).join(" ¬∑ ") || "‚è± -";
                meta.appendChild(when);

                const strategy = document.createElement("span");
                strategy.textContent = m?.extractionStrategy ? `‚öô ${m.extractionStrategy}` : "";
                if (strategy.textContent) meta.appendChild(strategy);

                const text = document.createElement("div");
                text.className = "text";
                text.textContent = (m?.text || "").toString();

                item.appendChild(meta);
                item.appendChild(text);
                chatPreviewEl.appendChild(item);
            }

            // Auto-scroll to bottom
            try { chatPreviewEl.scrollTop = chatPreviewEl.scrollHeight; } catch { }
        }

        // ---------------------------
        // HTTP Actions
        // ---------------------------
        async function postOpen() {
            const { baseUrl, apiPrefix, sessionId } = getConfig();
            setHttpState("idle");
            const url = `${baseUrl}${apiPrefix}/linkedin/open`;

            setHttpState("ok", "open...");
            appendLog("POST /linkedin/open", { url, sessionId });

            try {
                const data = await fetchJson(url, {
                    method: "POST",
                    body: JSON.stringify({ sessionId }),
                });
                setHttpState("ok", "open ok");
                outEl.textContent = safeJson(data);
                appendLog("open response", data);
            } catch (e) {
                setHttpState("error", e.message);
                outEl.textContent = safeJson({ error: e.message, payload: e.payload || null });
                appendLog("open error", { message: e.message, payload: e.payload || null });
            }
        }

        function buildWarmUpBody() {
            const { sessionId } = getConfig();
            const linkedinUrl = $("warmLinkedinUrl").value.trim();
            const lastMessageStr = $("warmLastMessageStr").value || "";

            // üîÅ Si tu backend usa "profileUrl" en vez de "linkedinUrl", cambi√° ac√°:
            // return { sessionId, profileUrl: linkedinUrl, lastMessageStr: lastMessageStr.trim() };

            return {
                sessionId,
                linkedinUrl,
                lastMessageStr: lastMessageStr.trim(),
            };
        }

        async function postStartWarmUp() {
            const { baseUrl, apiPrefix } = getConfig();
            const url = `${baseUrl}${apiPrefix}/linkedin/start-warm-up`;

            const body = buildWarmUpBody();

            if (!body.linkedinUrl) {
                setWarmState("error", "linkedinUrl requerido");
                outEl.textContent = safeJson({ error: "linkedinUrl requerido" });
                return;
            }

            // lastMessageStr puede venir vac√≠o si quer√©s arrancar ‚Äúdesde cero‚Äù
            setWarmState("running", "starting...");
            setHttpState("ok", "start-warm-up...");

            appendLog("POST /linkedin/start-warm-up", {
                url,
                body: { ...body, lastMessageStr: `(len=${(body.lastMessageStr || "").length})` },
            });

            try {
                // ‚è±Ô∏è margen grande por tab + carga
                const data = await fetchJson(url, {
                    method: "POST",
                    body: JSON.stringify(body),
                }, 10 * 60 * 1000); // 10 min

                setWarmState("ok", "started");
                setHttpState("ok", "warm-up ok");
                outEl.textContent = safeJson(data);
                appendLog("start-warm-up response", data);
            } catch (e) {
                setWarmState("error", e.message);
                setHttpState("error", e.message);
                outEl.textContent = safeJson({ error: e.message, payload: e.payload || null });
                appendLog("start-warm-up error", { message: e.message, payload: e.payload || null });
            }
        }

        function buildSendSalesNavBody() {
            const { sessionId } = getConfig();
            const profileUrl = $("snProfileUrl").value.trim();
            const message = $("snMessage").value;
            const subject = $("snSubject").value.trim();

            const body = { sessionId, profileUrl, message: (message || "").trim() };
            if (subject) body.subject = subject;
            return body;
        }

        async function postSendSalesNavMessage() {
            const { baseUrl, apiPrefix } = getConfig();
            const url = `${baseUrl}${apiPrefix}/linkedin/send-salesnav-message`;

            const body = buildSendSalesNavBody();

            if (!body.profileUrl) {
                setHttpState("error", "profileUrl requerido");
                outEl.textContent = safeJson({ error: "profileUrl requerido" });
                return;
            }
            if (!body.message || !body.message.trim()) {
                setHttpState("error", "message requerido");
                outEl.textContent = safeJson({ error: "message requerido" });
                return;
            }

            setHttpState("ok", "send-salesnav-message...");
            appendLog("POST /linkedin/send-salesnav-message", {
                url,
                body: { ...body, message: `(len=${(body.message || "").length})` }
            });

            try {
                const data = await fetchJson(url, {
                    method: "POST",
                    body: JSON.stringify(body),
                });

                setHttpState("ok", "send ok");
                outEl.textContent = safeJson(data);
                appendLog("send-salesnav-message response", data);
            } catch (e) {
                setHttpState("error", e.message);
                outEl.textContent = safeJson({ error: e.message, payload: e.payload || null });
                appendLog("send-salesnav-message error", { message: e.message, payload: e.payload || null });
            }
        }

        function buildReadSalesNavBody() {
            const { sessionId } = getConfig();
            const profileUrl = $("snReadProfileUrl").value.trim();
            const limitRaw = Number($("snReadLimit").value || 30);
            const limit = Math.max(1, Math.min(200, isFinite(limitRaw) ? limitRaw : 30));
            const threadHint = $("snReadThreadHint").value.trim();
            const taskId = $("snReadTaskId").value.trim();

            const body = { sessionId, profileUrl, limit };
            if (threadHint) body.threadHint = threadHint;
            if (taskId) body.taskId = taskId;
            return body;
        }

        async function postReadSalesNavChat() {
            const { baseUrl, apiPrefix } = getConfig();
            const url = `${baseUrl}${apiPrefix}/linkedin/read-salesnav-chat`;

            const body = buildReadSalesNavBody();

            if (!body.profileUrl) {
                setSnReadState("error", "profileUrl requerido");
                outEl.textContent = safeJson({ error: "profileUrl requerido" });
                clearChatPreview("Falta profileUrl para leer el chat.");
                return;
            }

            setSnReadState("running", "reading...");
            setHttpState("ok", "read-salesnav-chat...");

            appendLog("POST /linkedin/read-salesnav-chat", { url, body });

            try {
                // ‚è±Ô∏è darle margen por navegaci√≥n + abrir overlay + scroll/extract
                const data = await fetchJson(url, {
                    method: "POST",
                    body: JSON.stringify(body),
                }, 6 * 60 * 1000); // 6 min

                setSnReadState("ok", "done");
                setHttpState("ok", "read ok");
                outEl.textContent = safeJson(data);
                appendLog("read-salesnav-chat response", data);

                // Render preview
                try { renderChatPreview(data); } catch (e) {
                    appendLog("renderChatPreview error", { error: String(e) });
                    clearChatPreview("No pude renderizar el chat preview (ver logs).");
                }
            } catch (e) {
                setSnReadState("error", e.message);
                setHttpState("error", e.message);
                outEl.textContent = safeJson({ error: e.message, payload: e.payload || null });
                appendLog("read-salesnav-chat error", { message: e.message, payload: e.payload || null });
                clearChatPreview("Error leyendo el chat (ver Output/Logs).");
            }
        }

        function cmdReload() {
            emitInput({ type: "cmd", command: "reload" });
        }

        function cmdListTabs() {
            emitInput({ type: "cmd", command: "listTabs" });
        }

        // ---------------------------
        // Wire UI
        // ---------------------------
        $("btnConnect").addEventListener("click", () => connectSocket());
        $("btnDisconnect").addEventListener("click", () => disconnectSocket());

        $("btnOpen").addEventListener("click", () => postOpen());
        $("btnReload").addEventListener("click", () => cmdReload());
        $("btnListTabs").addEventListener("click", () => cmdListTabs());

        $("btnSendSalesNavMessage").addEventListener("click", () => postSendSalesNavMessage());
        $("btnReadSalesNavChat").addEventListener("click", () => postReadSalesNavChat());

        $("btnStartWarmUp").addEventListener("click", () => postStartWarmUp());

        $("btnCopyWarmUpBody").addEventListener("click", async () => {
            try {
                const body = buildWarmUpBody();
                await navigator.clipboard.writeText(JSON.stringify(body, null, 2));
                appendLog("WarmUp JSON copiado al clipboard", { keys: Object.keys(body) });
            } catch (e) {
                appendLog("No pude copiar WarmUp JSON", { error: String(e) });
            }
        });

        $("btnCopySendSalesNavBody").addEventListener("click", async () => {
            try {
                const body = buildSendSalesNavBody();
                // no copiar el mensaje entero si quer√©s: ac√° lo copiamos completo igual
                await navigator.clipboard.writeText(JSON.stringify(body, null, 2));
                appendLog("Send SalesNav JSON copiado al clipboard", { keys: Object.keys(body) });
            } catch (e) {
                appendLog("No pude copiar Send SalesNav JSON", { error: String(e) });
            }
        });

        $("btnCopyReadSalesNavBody").addEventListener("click", async () => {
            try {
                const body = buildReadSalesNavBody();
                await navigator.clipboard.writeText(JSON.stringify(body, null, 2));
                appendLog("Read SalesNav JSON copiado al clipboard", { keys: Object.keys(body) });
            } catch (e) {
                appendLog("No pude copiar Read SalesNav JSON", { error: String(e) });
            }
        });

        $("btnSyncProfileUrl").addEventListener("click", () => {
            const v = $("snProfileUrl").value.trim();
            if (v) {
                $("snReadProfileUrl").value = v;
                appendLog("ProfileUrl sync: Send ‚Üí Read", { profileUrl: v });
            } else {
                appendLog("ProfileUrl sync: no hay valor en Send");
            }
        });

        $("btnClear").addEventListener("click", () => {
            outEl.textContent = "{}";
            clearChatPreview("Limpiado. Ejecut√° read-salesnav-chat para ver mensajes.");
            appendLog("Limpiar output + chat preview");
        });

        $("btnCopyJson").addEventListener("click", async () => {
            try {
                await navigator.clipboard.writeText(outEl.textContent || "");
                appendLog("JSON copiado al clipboard");
            } catch (e) {
                appendLog("No pude copiar JSON", { error: String(e) });
            }
        });

        // Defaults
        (function initDefaults() {
            $("baseUrl").value = "http://localhost:3001";
            $("apiPrefix").value = "/api/zion";

            setWsState("disconnected");
            setHttpState("idle");
            setWarmState("idle");
            setSnReadState("idle");
            setStreamFocus(false);

            clearChatPreview("Todav√≠a no hay resultados. Ejecut√° read-salesnav-chat.");
            appendLog("UI listo. Acciones: open + send-salesnav-message + read-salesnav-chat + warm-up. Sin storage.");
        })();
    </script>
</body>

</html>